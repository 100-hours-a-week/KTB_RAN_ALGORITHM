## 🧩 문제

* **문제 제목** : 소수 구하기
* **문제 레벨** : Silver III
* **문제 유형** : 수학, 소수 판정, 브루트포스
* **문제 제공** : BOJ
* **문제 링크** : https://www.acmicpc.net/problem/1929
* **코드 파일** : [prime-number-1929.js](../../algorithm-JS/Search_Graph/prime-number-1929.js)

---

## 🧩 문제 설명

정수 `M`, `N`이 주어졌을 때, `M` 이상 `N` 이하의 소수를 모두 출력하는 문제다.

---

## 🧩 문제 핵심 포인트

* 어떤 수 `i`가 소수인지 확인할 때 `2`부터 `sqrt(i)`까지만 나눠보면 충분하다.
* `1`은 소수가 아니므로 별도로 제거해야 한다.
* 구간 `[M, N]`의 모든 수에 대해 소수 판정을 수행하면 된다.

---

## 🧩 내 풀이 방식

* `[a, b]` 구간 숫자를 배열 `arr`에 담는다.
* `Set`으로 복사해 후보 집합 `arrSet`을 만든다.
* 각 수 `i`에 대해:
  `i === 1`이면 제거하고,
  `j = 2`부터 `j * j <= i`까지 나눠서 약수가 있으면 `arrSet`에서 제거한다.
* 마지막에 `arrSet`을 줄바꿈 문자열로 합쳐 출력한다.

---

## 🧩 코드 로직 정리

### 전체 흐름

```txt
1. a, b 입력
2. a~b 숫자를 arr에 저장
3. arr로 Set(arrSet) 생성
4. arr를 순회하며
   - 1 제거
   - 2~sqrt(i) 범위에서 약수 확인
   - 약수 있으면 Set에서 제거
5. Set에 남은 수(소수)를 줄바꿈으로 출력
```

---

## 🧩 코드 구현 (내 풀이)

```js
const fs = require("fs");
const input = fs.readFileSync(0, "utf-8").trim().split("\n");

function solution(a, b) {
  const arr = [];

  for (let i = a; i <= b; i++) {
    arr.push(i);
  }

  const arrSet = new Set([...arr]);

  for (const i of arr) {
    if (i === 1) arrSet.delete(i);
    for (let j = 2; j * j <= i; j++) {
      if (i % j === 0) {
        arrSet.delete(i);
      }
    }
  }

  return [...arrSet].join("\n");
}

const [a, b] = input[0].split(" ").map(Number);

console.log(solution(a, b));
```

---

## 🧩 사용된 JS 개념

* `Set` : 소수가 아닌 수를 삭제하며 후보 관리
* 배열 전개 `...` : 배열을 Set으로 초기화
* `join("\n")` : 출력 형식에 맞게 줄바꿈 문자열 생성

---

## 🧩 복잡도

* 시간복잡도 : `O((b - a + 1) * sqrt(b))`
* 공간복잡도 : `O(b - a + 1)` (배열 + Set)

---

## 🧠 사고 키워드

* 소수 판정
* 제곱근 경계
* 후보 제거 방식

---

## 🔍 트리거 문장

* "M 이상 N 이하의 소수를 모두 출력"
* "소수인지 판별해서 출력"
* "구간 내 숫자 필터링"

---

## ⚠️ 오답 포인트

* `1`을 소수로 남겨두면 오답이다.
* 약수 검사 범위를 `i-1`까지 돌면 시간 낭비가 크다.
* 줄바꿈 출력 형식을 지키지 않으면 정답이어도 틀릴 수 있다.
