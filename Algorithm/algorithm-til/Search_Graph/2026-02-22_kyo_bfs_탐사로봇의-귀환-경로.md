## 🧩 문제

- **문제 제목** : 탐사로봇의 귀환 경로
- **문제 레벨** : 강의 문제집
- **문제 유형** : BFS, 2차원 격자 최단거리
- **문제 제공** : Inflearn Kyo
- **문제 링크** : 강의 문제집 내 제공 문제
- **코드 파일** : [explorer-return-path-kyo.js](../../algorithm-JS/Search_Graph/explorer-return-path-kyo.js)

---

## 🧩 문제 설명

격자 `maps`에서 `(0,0)`에서 시작해 `(n-1,m-1)`까지 이동한다.  
`1`은 이동 가능, `0`은 벽이다.  
상하좌우 이동만 가능할 때 최소 이동 칸 수를 구한다.  
도달 불가면 `-1`을 반환한다.

### 📌 유형 감지 메모 (최단거리)

- 문제 문장에서 `최소 이동 횟수`, `최단 거리`, `몇 초 만에`, `가장 빠르게` 같은 표현이 보이면 먼저 거리 최소화 유형으로 본다.
- 그다음 확인할 질문은 하나다: `이동 비용(가중치)이 모두 같은가?`
- 이 문제처럼 한 칸 이동 비용이 동일한 격자라면, 최단거리는 `BFS`로 처리한다.

---

## 🧩 문제 핵심 포인트

- 이 문제는 그래프 `BFS` 유형이며, 공통 판단 기준은 위 세션 문서와 동일하다.
- 가중치 없는 격자 최단거리라 BFS가 정석이다.
- `dist[x][y]`에 시작점부터의 최소 이동 횟수를 저장한다.
- 방문 처리는 `maps[nx][ny] = 0`으로 처리해 중복 방문을 막는다.

---

## 🧩 내 풀이 방식

- 시작점 `(0,0)`을 큐에 넣고 `dist[0][0] = 1`로 초기화.
- 큐에서 하나씩 꺼내 4방향을 검사.
- 범위 안이고 값이 1이면:
  - 큐에 넣고
  - 방문 처리하고
  - `dist[nx][ny] = dist[x][y] + 1`로 갱신.
- BFS 종료 후 `dist[n-1][m-1]` 반환, 0이면 `-1`.

---

## 🧩 코드 로직 정리

### 전체 흐름

```txt
1. 시작점 큐에 넣기
2. dist[0][0] = 1
3. 큐에서 꺼내며 4방향 탐색
4. 갈 수 있으면 방문 처리 + dist 갱신 + 큐 삽입
5. 마지막 칸 값 반환 (없으면 -1)
```

---

## 🧩 코드 구현 (내 풀이)

```js
function solution(maps) {
  const n = maps.length;
  const m = maps[0].length;

  // 상하좌우 이동 방향
  const dx = [-1, 0, 1, 0];
  const dy = [0, 1, 0, -1];

  // 거리 배열
  const dist = Array.from({ length: n }, () => Array(m).fill(0));

  // BFS 큐
  const queue = [[0, 0]];

  // 시작점 초기화
  //d(방문 거리용[미래])와 maps(지나쳐온 거리[과거])은 항상 같이 다닌다.
  dist[0][0] = 1;
  maps[0][0] = 0; // 방문 처리

  while (queue.length) {
    const [x, y] = queue.shift();

    for (let dir = 0; dir < 4; dir++) {
      const nx = x + dx[dir];
      const ny = y + dy[dir];

      // 범위 안이고, 이동 가능하면
      if (nx >= 0 && nx < n && ny >= 0 && ny < m && maps[nx][ny] === 1) {
        queue.push([nx, ny]);
        maps[nx][ny] = 0; // 방문 처리
        dist[nx][ny] = dist[x][y] + 1; // 거리 갱신
      }
    }
  }

  // 도착점 거리 반환 (없으면 -1)
  return dist[n - 1][m - 1] || -1;
}
```

---

## 🧩 사용된 JS 개념

- 2차원 배열 생성: `Array.from`
- 방향 벡터: `dx`, `dy`
- 큐 + `head` 포인터: BFS 성능 최적화

---

## 🧩 복잡도

- 시간복잡도 : `O(n*m)`
- 공간복잡도 : `O(n*m)` (`dist` + queue)

---

## 🧠 사고 키워드

- 가중치 없는 최단거리
- BFS 레벨 탐색
- 격자 4방향 이동

---

## 🔍 트리거 문장

- "(0,0)에서 도착점까지 최소 이동"
- "격자 + 상하좌우"
- "1은 이동 가능, 0은 벽"

---

## ⚠️ 오답 포인트

- `nextY = y + dx[k]`처럼 축을 섞으면 탐색이 깨진다 (`dy`를 써야 함).
- 방문 처리를 늦게 하면 같은 칸이 여러 번 큐에 들어가 비효율이 커진다.
- `queue.shift()`만 사용하면 입력이 클 때 성능이 떨어질 수 있다.

---

## 📌 쉽게 적어둔 구조

### 문제 유형

- 2차원 격자
- (0,0) -> (n-1,m-1)
- 1은 이동 가능, 0은 벽
- 최단 거리 구하기

=> **BFS 최단거리 기본형**

### 핵심 개념 정리

1. 왜 BFS인가?

   - 가중치 없음
   - 한 칸 이동 비용 동일
   - 먼저 도착한 경로가 최단 거리

2. 거리 배열 `dist`

   - `dist[x][y]` = 시작점에서 `(x,y)`까지의 최소 이동 횟수
   - 시작점은 1부터 시작

3. 방문 처리
   - `maps[nextX][nextY] = 0`
   - 다시 방문하지 않기 위함

### 나중에 기억하기 쉬운 요약

```txt
1. 시작점 큐에 넣기
2. dist[0][0] = 1
3. 큐에서 꺼내면서 4방향 탐색
4. 갈 수 있으면:
   - 방문 처리
   - dist 갱신
   - 큐에 추가
5. 마지막 칸 값 반환
```

### BFS 기본 구조 수도코드

```txt
queue.push(start)
visited 처리

while(queue not empty):
    현재 꺼내기
    for 4방향:
        범위 체크
        방문 안했으면:
            방문 처리
            거리 = 이전 + 1
            queue.push
```

### 작은 개선 팁 (성능)

- `shift()`는 `O(N)`이라 큰 입력에서는 head 포인터 방식이 더 좋다.

### 필요한 사고 흐름

1. 본질:

   - `(0,0)`에서 `(n-1,m-1)`까지 최소 칸 수
   - 가중치 없는 격자 최단거리 => BFS

2. 푸는 구조:

   - 거리판 `dist` 생성
   - 큐 생성
   - 시작점 넣고 출발
   - 큐가 빌 때까지 4방향 탐색
   - 갈 수 있으면 큐 추가 + 방문 처리 + 거리 갱신

3. 왜 최소 거리인가?

   - BFS는 거리 1, 2, 3 순으로 레벨 단위 확장
   - 처음 도달한 값이 최소 거리

4. 종료:
   - `dist[n-1][m-1] === 0`이면 도달 실패 -> `-1`

### 4줄 암기

```txt
1. BFS는 최단거리
2. dist 배열 필요
3. 4방향 탐색
4. 방문 처리 후 큐에 넣기
```
