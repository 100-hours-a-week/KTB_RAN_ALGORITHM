## 🧩 문제

- **문제 제목** : 유기농 배추
- **문제 레벨** : Silver II
- **문제 유형** : BFS/DFS, 2차원 격자, 연결 요소 개수 세기
- **문제 제공** : BOJ
- **문제 링크** : https://www.acmicpc.net/problem/1012
- **코드 파일** : [organic-cabbage-1012.js](../../algorithm-JS/Search_Graph/organic-cabbage-1012.js)

---

## 🧩 문제 설명

배추가 심어진 칸만 `1`, 나머지는 `0`으로 본다.  
상하좌우로 붙어 있는 배추는 같은 그룹(한 마리 지렁이로 커버 가능)이다.  
각 테스트케이스마다 **배추 그룹(덩어리) 개수**를 구하면 된다.

---

## 🧩 문제 핵심 포인트

- 한 줄 핵심: **미로탐색처럼 BFS를 쓰지만, 목표는 최단거리가 아니라 "덩어리 개수 세기"다.** == **미로탐색 + 연결요소 갯수**
- `graph[i][j] === 1`인 칸을 시작점으로 BFS를 한 번 돌리면 해당 덩어리를 전부 지운다.
- BFS를 시작할 때마다 `count++` 하면 최종적으로 덩어리 개수가 된다.
- 이 문제는 테스트케이스가 여러 개라서, 케이스마다 `graph`, `count`, `queue`를 새로 초기화해야 한다.

### 📌 유형 감지 메모

- 키워드가 `최단 거리`면 미로탐색 쪽(BFS 거리 계산)
- 키워드가 `몇 개`, `그룹`, `연결된 덩어리`면 연결요소 카운팅(BFS/DFS)

---

## 🧩 미로탐색(2178)과 차이

- 미로탐색: 시작점 -> 도착점까지 **최소 거리**
- 유기농 배추: 전체 격자를 돌면서 **덩어리 개수**

그래서 이 문제는 `dist` 배열이 필요 없다.  
방문 여부만 관리하면 충분하고, 현재 코드는 방문 처리를 `graph[x][y] = 0`으로 하고 있다.

---

## 🧩 내 풀이 방식

- `N x M` 격자를 0으로 만들고, 입력 좌표(`arr`)를 `1`로 채운다.
- 격자 전체를 순회한다.
- `1`을 만나면:
  - `count++`
  - 그 칸을 0으로 바꾸고 큐에 넣는다.
  - BFS로 연결된 1들을 전부 0으로 바꾼다.
- 모든 칸 순회 후 `count` 반환.

---

## 🧩 코드 로직 정리

### 전체 흐름

```txt
1. 테스트케이스 수 T 입력
2. 각 케이스마다 graph 초기화
3. 배추 좌표를 graph[u][v] = 1로 표시
4. graph 전체 순회
5. 1을 만나면 count++ 후 BFS 시작
6. BFS로 같은 덩어리의 1을 전부 0으로 변경
7. count 출력
```

### BFS 역할

```txt
queue에서 현재 칸을 꺼내고
상하좌우를 본다.
범위 안 + 값이 1이면
0으로 바꾸고 queue에 넣는다.
```

---

## 🧩 코드 구현 (내 풀이)

```js
const fs = require("fs"); // /dev/stdin
const input = fs.readFileSync("../예제.txt").toString().trim().split("\n");

//백준 제출 시
// const fs = require("fs");
// const input = fs.readFileSync(0, "utf-8").trim().split("\n");

//해당 문제는 뭉쳐있는 그룹 갯수 세는 거임.

function bfs(dx, dy, N, M, graph, queue) {
  while (queue.length) {
    //현재 있는 위치
    let [curX, curY] = queue.shift();

    for (let i = 0; i < 4; i++) {
      let nextX = curX + dx[i];
      let nextY = curY + dy[i];

      if (
        nextX >= 0 &&
        nextX < N &&
        nextY >= 0 &&
        nextY < M &&
        graph[nextX][nextY] === 1
      ) {
        graph[nextX][nextY] = 0;
        queue.push([nextX, nextY]);
      }
    }
  }
}

function solution(N, M, K, arr) {
  const graph = Array.from({ length: N }, () => Array(M).fill(0));
  //인접 행렬로 만들기
  for (let [u, v] of arr) {
    graph[u][v] = 1;
  }

  let count = 0;
  let queue = [];

  let dx = [-1, 0, 1, 0];
  let dy = [0, 1, 0, -1];

  for (let i = 0; i < N; i++) {
    for (let j = 0; j < M; j++) {
      if (graph[i][j] === 1) {
        let start = [i, j];
        graph[i][j] = 0;
        queue.push(start);
        count++;
        bfs(dx, dy, N, M, graph, queue);
      }
    }
  }

  return count;
}

const forNum = Number(input[0]);
let idx = 1;

for (let i = 0; i < forNum; i++) {
  let [N, M, K] = input[idx++].split(" ").map(Number);
  let arr = [];

  for (let j = 0; j < K; j++) {
    arr.push(input[idx++].split(" ").map(Number));
  }

  console.log(solution(N, M, K, arr));
}
```

---

## 🧩 사용된 JS 개념

- 2차원 배열 생성: `Array.from`
- 큐 기반 BFS: `push`, `shift`
- 다중 테스트케이스 입력 처리: 인덱스 포인터(`idx`)

---

## 🧩 복잡도

- 시간복잡도 : `O(N*M)` (케이스 하나 기준)
- 공간복잡도 : `O(N*M)`

---

## 🧠 사고 키워드

- 연결 요소 개수
- 격자 BFS/DFS
- 방문 처리로 덩어리 소거

---

## 🔍 트리거 문장

- "서로 인접한 배추"
- "필요한 지렁이 수"
- "몇 개의 그룹"

---

## ⚠️ 헷갈렸던 포인트 / 오답 포인트

- 미로탐색처럼 `dist`를 만들 필요가 없다. 이 문제는 거리 문제가 아니다.
- 시작점 하나 찾았다고 끝이 아니다. 전체 격자를 다 돌면서 새로운 덩어리를 찾아야 한다.
- 입력 좌표를 `graph[u][v]`로 넣을 때 축을 바꾸면 결과가 틀어진다.
- 테스트케이스마다 자료구조를 새로 만들지 않으면 이전 케이스 값이 섞인다.
- 큐를 외부에서 재사용할 때는 BFS가 끝난 뒤 비어 있다는 전제가 있어야 한다.
