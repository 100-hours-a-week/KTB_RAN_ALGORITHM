## 🧩 문제

- **문제 제목** : 단지번호붙이기
- **문제 레벨** : Silver I
- **문제 유형** : BFS/DFS, 2차원 격자, 연결 요소
- **문제 제공** : BOJ
- **문제 링크** : https://www.acmicpc.net/problem/2667
- **코드 파일** : [apartment-complex-2667.js](../../algorithm-JS/Search_Graph/apartment-complex-2667.js)

---

## 🧩 문제 설명

`1`은 집, `0`은 빈 칸인 `N x N` 지도가 주어진다.  
상하좌우로 연결된 집들을 하나의 단지로 보고, 전체 단지 수와 각 단지의 집 수를 오름차순으로 출력하면 된다.

---

## 🧩 문제 핵심 포인트

- 이 문제는 최단 거리 문제가 아니라 연결 요소(덩어리) 개수와 크기를 구하는 문제이다.
- 격자를 순회하면서 `1`을 발견할 때마다 BFS를 1회 실행하면 단지 1개가 완전히 처리된다.
- 연결 요소 문제에서는 BFS 실행 단위가 독립적이므로, BFS마다 큐를 새로 만드는 구조가 안전하다.

---

## 🧩 내 풀이 방식

- 전체 격자를 순회하다가 `graph[i][j] === 1`이면 새로운 단지를 찾은 것으로 본다.
- 시작점을 큐에 넣고 BFS를 돌려 해당 단지의 모든 집을 `0`으로 방문 처리한다.
- BFS에서 탐색한 집 개수를 반환받아 배열에 저장하고, 마지막에 정렬해서 출력한다.

---

## 🧩 코드 로직 정리

### 전체 흐름

```txt
1. 격자를 전부 순회한다.
2. 값이 1인 칸을 만나면 그룹 수를 증가시키고 큐를 새로 생성한다.
3. BFS로 연결된 집들을 모두 방문 처리(0으로 변경)한다.
4. BFS가 반환한 단지 크기를 배열에 저장한다.
5. 단지 수와 정렬된 단지 크기 목록을 출력한다.
```

---

## 🧩 코드 구현 (내 풀이)

```js
const fs = require("fs"); // /dev/stdin
const input = fs.readFileSync("../예제.txt").toString().trim().split("\n");

//백준 제출 시
// const fs = require("fs");
// const input = fs.readFileSync(0, "utf-8").trim().split("\n");

//연결 요소 갯수 구하기 : BFS

function bfs(queue, graph, dx, dy, n, count) {
  while (queue.length) {
    let [curX, curY] = queue.shift();
    //상하좌우를 모두 확인해야됨.
    for (let i = 0; i < 4; i++) {
      let nextX = curX + dx[i];
      let nextY = curY + dy[i];

      if (
        nextX >= 0 &&
        nextX < n &&
        nextY >= 0 &&
        nextY < n &&
        graph[nextX][nextY] === 1
      ) {
        count++;
        queue.push([nextX, nextY]);
        graph[nextX][nextY] = 0;
      }
    }
  }

  return count;
}

function solution(n, graph) {
  //방문한 곳이 필요하고,
  //발자취 queue로 이동

  const answer = [];
  let groupCount = 0;

  let dx = [-1, 0, 1, 0];
  let dy = [0, 1, 0, -1];

  //방문한 곳은 0으로 처리할 것임.
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      let count = 1;
      if (graph[i][j] === 1) {
        groupCount++;
        const queue = [];
        queue.push([i, j]);
        graph[i][j] = 0;
        count = bfs(queue, graph, dx, dy, n, count);
        answer.push(count);
      }
    }
  }

  return groupCount + "\n" + answer.sort((a, b) => a - b).join("\n");
}

const n = Number(input[0]);
const arr = input.slice(1).map((i) => i.split("").map(Number));

console.log(solution(n, arr));
```

---

## 🧩 사용된 JS 개념

- `Array.prototype.shift()` : 큐의 맨 앞 원소를 꺼내 BFS 순서대로 탐색한다.
- `Array.prototype.push()` : 인접한 다음 탐색 좌표를 큐 뒤에 추가한다.
- `Array.prototype.sort((a, b) => a - b)` : 단지별 집 수를 오름차순 정렬한다.

---

## 🧩 복잡도

- 시간복잡도 : `O(N^2)` 방문 + `shift()` 연산 누적으로 구현상 최악 `O(N^4)` 가능
- 공간복잡도 : `O(N^2)` (격자 + 큐)

---

## 🧠 사고 키워드

- 연결 요소 문제는 "방문 안 한 시작점마다 BFS 1회" 구조이다.
- BFS 1회는 단지 1개를 전부 소거하는 작업이다.
- 큐는 탐색 상태이므로 BFS 단위마다 독립 생성하는 편이 안전하다.

---

## 🔍 트리거 문장

- "연결된 집의 모임"
- "단지 수"
- "각 단지 내 집의 수"

---

## ⚠️ 오답 포인트

- BFS 시작 전에 `graph[i][j] = 0` 처리를 안 하면 중복 방문이 생긴다.
- 연결 요소 문제에서 큐를 전역 재사용하면 탐색 상태가 섞일 위험이 있다.
- 출력 시 단지 크기 배열을 오름차순 정렬하지 않으면 형식 오답이 난다.
