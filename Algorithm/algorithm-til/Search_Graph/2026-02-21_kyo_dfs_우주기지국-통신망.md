## 🧩 문제

* **문제 제목** : 우주기지국 통신망
* **문제 레벨** : 강의 문제집
* **문제 유형** : DFS/BFS, 그래프, 연결 요소 개수
* **문제 제공** : Inflearn Kyo
* **문제 링크** : 강의 문제집 내 제공 문제
* **코드 파일** : [space-station-network-dfs.js](../../algorithm-JS/Search_Graph/space-station-network-dfs.js)

---

## 🧩 문제 설명

우주 기지국 `n`개와 기지국 간 직접 통신 여부가 `n x n` 행렬로 주어진다.  
직접 또는 간접 통신이 가능하면 같은 통신망으로 본다.  
서로 독립적인 통신망(연결 요소)의 개수를 구하는 문제다.

---

## 🧩 문제 핵심 포인트

* 통신 가능 관계는 무방향 그래프의 연결 관계로 해석할 수 있다.
* 핵심은 모든 노드를 돌면서 방문하지 않은 노드에서 DFS를 시작하는 것.
* DFS 한 번이 끝날 때마다 하나의 통신망을 모두 방문한 것이므로 개수를 1 증가한다.

---

## 🧩 내 풀이 방식

* `visited` 집합으로 방문 여부를 관리한다.
* `dfs(start)`에서 `stations[start][next] === 1`인 노드 중 미방문 노드를 재귀 방문한다.
* `i = 0..n-1` 순회 중 미방문 노드를 만나면 DFS 시작 후 `count++`.
* 최종 `count`를 반환한다.

---

## 🧩 코드 로직 정리

### 전체 흐름

```txt
1. visited 집합, count=0 초기화
2. 각 노드 i를 순회
3. i가 미방문이면 dfs(i) 실행
4. dfs가 끝나면 count++
5. 모든 노드 순회 후 count 반환
```

---

## 🧩 코드 구현 (내 풀이)

```js
const fs = require("fs");
const input = fs.readFileSync(0, "utf-8").trim().split("\n");

function solution(n, stations) {
  const visited = new Set();
  let count = 0;

  function dfs(start) {
    visited.add(start);

    for (let next = 0; next < n; next++) {
      if (stations[start][next] === 1 && !visited.has(next)) {
        dfs(next);
      }
    }
  }

  for (let i = 0; i < n; i++) {
    if (!visited.has(i)) {
      dfs(i);
      count += 1;
    }
  }

  return count;
}

const n = Number(input[0]);
const stations = input.slice(1, n + 1).map((line) => line.split(" ").map(Number));

console.log(solution(n, stations));
```

---

## 🧩 사용된 JS 개념

* `Set` : 방문 노드 관리
* 재귀 함수 : DFS 구현
* 2차원 배열 인덱싱 : 인접 행렬 순회

---

## 🧩 복잡도

* 시간복잡도 : `O(n^2)` (인접 행렬 전체 탐색)
* 공간복잡도 : `O(n)` (visited + 재귀 스택)

---

## 🧠 사고 키워드

* 연결 요소
* DFS 순회
* 방문 체크

---

## 🔍 트리거 문장

* "직접 또는 간접 통신 가능"
* "서로 독립적인 통신망 개수"
* "n x n 통신 여부 행렬"

---

## ⚠️ 오답 포인트

* 방문 배열/집합 없이 DFS를 돌면 중복 탐색으로 시간 낭비와 오답이 발생한다.
* `stations[i][i] === 1` 조건 때문에 자기 자신 간선 처리만 하고 종료하면 안 된다.
* 미방문 노드 기준으로 DFS를 새로 시작하지 않으면 통신망 개수를 정확히 세지 못한다.
