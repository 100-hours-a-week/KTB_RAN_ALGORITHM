## 🧩 문제

- **문제 제목** : 도시의 안전거리
- **문제 레벨** : 강의 문제집
- **문제 유형** : 그래프 BFS, 무방향 그래프 최단거리
- **문제 제공** : Inflearn Kyo
- **문제 링크** : 강의 문제집 내 제공 문제
- **코드 파일** : [city-safety-distance-kyo.js](../../algorithm-JS/Search_Graph/city-safety-distance-kyo.js)

---

## 🧩 문제 설명

도시를 노드, 도로를 간선으로 본다.  
시작 도시 `start`에서 출발해서 다른 도시까지 가는 최소 이동 횟수를 구한다.  
그중에서 **가장 멀리 있는 도시까지의 거리**를 반환하면 된다.

예를 들어 시작점에서 어떤 도시는 1번 만에, 어떤 도시는 2번 만에, 어떤 도시는 3번 만에 갈 수 있다면 정답은 `3`이다.

### 문제 유형 정리 세션

- [개념 정리] 그래프 BFS / DFS: [2026-02-21_algo_그래프-BFS-DFS-정리.md](./2026-02-21_algo_그래프-BFS-DFS-정리.md)

### 📌 유형 감지 메모

- `최소 이동 횟수`, `가장 빨리`, `최단거리` 같은 말이 보이면 BFS를 먼저 떠올린다.
- 도로가 가중치 없이 같은 비용(한 번 이동)이라면 BFS가 잘 맞는다.

---

## 🧩 문제 핵심 포인트

- 그래프는 **무방향**이므로 `u -> v`, `v -> u` 둘 다 저장해야 한다.
- BFS는 가까운 도시부터 차례대로 탐색하므로 거리 계산이 쉽다.
- `d[next] = d[node] + 1` 한 줄이 핵심이다.
- 마지막에 `Math.max(...d)`를 쓰면 시작점에서 가장 먼 거리값을 얻을 수 있다.

---

## 🧩 내 풀이 방식

- 인접 리스트로 그래프를 만든다.
- `visited` 배열로 이미 본 도시는 다시 큐에 넣지 않는다.
- 큐에 `start`를 넣고 BFS를 돌린다.
- 처음 방문한 도시의 거리는 "이전 도시 거리 + 1"로 기록한다.
- 모든 탐색이 끝나면 거리 배열의 최댓값을 반환한다.

---

## 🧩 코드 로직 정리

### 전체 흐름

```txt
1. graph 인접 리스트 생성 (양방향)
2. visited, 거리 배열 d 준비
3. queue에 start 넣고 BFS 시작
4. 방문하지 않은 이웃을 만나면:
   - 방문 처리
   - 거리 = 이전 거리 + 1
   - queue에 넣기
5. 탐색 종료 후 Math.max(...d) 반환
```

### 동작 과정 (쉬운 예시)

예시:

```txt
n = 6
roads = [
  [1,2], [1,3], [2,4], [3,5], [5,6]
]
start = 1
```

인접 리스트:

```txt
1 -> [2,3]
2 -> [1,4]
3 -> [1,5]
4 -> [2]
5 -> [3,6]
6 -> [5]
```

초기 상태:

```txt
queue = [1]
d = [0,0,0,0,0,0,0]
visited[1] = true
```

BFS 진행:

```txt
1을 꺼냄 -> 2,3 방문
d[2]=1, d[3]=1, queue=[2,3]

2를 꺼냄 -> 4 방문
d[4]=2, queue=[3,4]

3을 꺼냄 -> 5 방문
d[5]=2, queue=[4,5]

4를 꺼냄 -> 새 방문 없음
queue=[5]

5를 꺼냄 -> 6 방문
d[6]=3, queue=[6]

6을 꺼냄 -> 종료
```

최종 거리:

```txt
노드:  1 2 3 4 5 6
거리:  0 1 1 2 2 3
```

정답:

```txt
Math.max(...d) = 3
```

즉, 시작 도시 `1`에서 가장 멀리 있는 도시는 거리 `3`이다.

---

## 🧩 코드 구현 (내 풀이)

```js
function solution(n, roads, start) {
  //인접리스트 방식으로 : 인접 리스트
  const graph = Array.from({ length: n + 1 }, () => []);
  for (const [u, v] of roads) {
    graph[u].push(v);
    graph[v].push(u);
  } //양방향 (무방향);

  const visited = Array(n + 1).fill(false); //방문
  const d = Array(n + 1).fill(0); //이동거리

  //bfs 탐색 시작
  const queue = [start];
  visited[start] = true;

  while (queue.length) {
    let node = queue.shift();
    for (let next of graph[node]) {
      if (!visited[next]) {
        visited[next] = true;
        d[next] = d[node] + 1;
        queue.push(next);
      }
    }
  }

  //거리 배열중 가장 큰 값
  return Math.max(...d);
}
```

---

## 🧩 사용된 JS 개념

- `Array.from` : 인접 리스트 생성
- `Array(n + 1).fill(...)` : 방문/거리 배열 생성
- `Math.max(...d)` : 거리 배열 최댓값 계산

---

## 🧩 복잡도

- 시간복잡도 : `O(V + E)` (BFS 기준)
- 공간복잡도 : `O(V + E)`

참고:

- 현재 코드는 큐에서 `shift()`를 쓰므로 입력이 매우 클 때는 비효율이 생길 수 있다.
- 큰 입력에서는 `head` 포인터 방식 큐가 더 안정적이다.

---

## 🧠 사고 키워드

- 무방향 그래프
- BFS
- 거리 배열
- 가장 먼 노드 거리

---

## 🔍 트리거 문장

- "시작점에서 가장 멀리"
- "최소 이동 횟수"
- "도로로 연결된 도시"

---

## ⚠️ 오답 포인트

- 무방향인데 한쪽 간선만 넣으면 거리 계산이 틀린다.
- 방문 체크 없이 큐에 넣으면 같은 노드가 여러 번 들어간다.
- `d[next] = d[node] + 1` 갱신을 빼먹으면 정답이 전부 0이 된다.
