## 🧩 문제

- **문제 제목** : 숨바꼭질 4
- **문제 레벨** : Gold V
- **문제 유형** : BFS, 최단거리, 경로 역추적
- **문제 제공** : BOJ
- **문제 링크** : https://www.acmicpc.net/problem/13913
- **코드 파일** : [hide-and-seek-4-13913.js](../../algorithm-JS/Search_Graph/hide-and-seek-4-13913.js)

---

## 🧩 문제 설명

수빈이는 `N`, 동생은 `K`에 있다.  
1초마다 `x-1`, `x+1`, `x*2` 중 하나로 이동할 수 있다.

이 문제는 2가지를 출력해야 한다.

1. 가장 빠른 시간
2. 실제 이동 경로

즉, "최단 시간"만 구하는 문제가 아니라 "최단 경로 복원"까지 필요한 BFS 문제다.

---

## 🧩 문제 핵심 포인트

- 한 줄 핵심: **격자 BFS의 4방향 대신, `[-1, +1, *2]` 세 방향 BFS + 부모 추적 문제다.**
- BFS는 먼저 방문한 경로가 최단거리다.
- 그래서 `parent[next] = node`를 "처음 방문할 때" 기록하면 그 부모 체인이 최단 경로가 된다.
- 목표 `K`를 찾으면 `K -> parent[K] -> ... -> N`으로 거꾸로 올라가서 경로를 복원할 수 있다.

---

## 🧩 내가 헷갈렸던 질문 정리

### Q1. 퍼지다가 K를 만나면 멈추는데, 왜 역추적이 가능하지?

- BFS는 레벨(시간) 순서로 퍼진다.
- 어떤 노드를 "처음" 방문한 순간의 경로가 그 노드로 가는 최단 경로다.
- 그래서 `parent`는 "정답이 되는 경로의 이전 칸"을 기억하는 배열이 된다.

### Q2. 역추적 한다고 해도 어떤 길이 정답인지 어떻게 알아?

- `visited[next]`가 `false`일 때만 처음 방문으로 인정한다.
- 그 순간 저장한 `parent[next]`가 최단거리 부모다.
- 나중에 다른 길로 다시 도달해도 `visited` 때문에 덮어쓰지 않는다.
- 따라서 `K`에서 `N`으로 parent를 따라가면 최단 경로가 맞다.

### Q3. 왜 이동 경로 전체를 매번 저장하지 않고 부모만 저장해?

- 매번 경로 전체를 저장하면 메모리와 연산이 커진다.
- 부모 하나만 저장하면 마지막에 한 번만 복원하면 된다.

---

## 🧩 내 풀이 방식

- `visited`: 방문 여부
- `dist`: 시작점에서 해당 위치까지 걸린 시간
- `parent`: 해당 위치로 "처음" 들어올 때의 이전 위치

BFS 중 `next === K`를 만나면 바로 경로 복원:

- `move = [K]`부터 시작
- `parent`를 따라 `N`까지 올라가기
- 마지막에 뒤집어서 출력

---

## 🧩 코드 로직 정리

### 전체 흐름

```txt
1. visited, dist, parent 배열 준비
2. queue에 N 넣고 BFS 시작
3. 현재 node에서 다음 3칸(node-1, node+1, node*2) 확인
4. 범위 안 + 미방문이면:
   - 방문 처리
   - parent[next] = node 저장
   - dist[next] = dist[node] + 1
5. next가 K면 즉시 parent 역추적으로 경로 복원
6. 시간 + 경로 문자열 반환
```

### 경로 복원 흐름

```txt
K부터 시작해서
parent[K], parent[parent[K]], ...
N을 만날 때까지 push
마지막에 reverse 하면 N -> ... -> K 경로 완성
```

---

## 🧩 코드 구현 (내 풀이)

```js
const fs = require("fs"); // /dev/stdin
const input = fs.readFileSync("../예제.txt").toString().trim().split("\n");

//백준 제출 시
// const fs = require("fs");
// const input = fs.readFileSync(0, "utf-8").trim().split("\n");

function solution(N, K) {
  //BFS

  //visited
  //queue
  const visited = Array(100001).fill(false); //방문했는지 여부 배열
  const dist = Array(100001).fill(0); //이동 거리 수 저장
  const queue = []; //방문한 노드 배열
  const parent = Array(100001).fill(-1); //부모 경로 : 사용방법 parend[1] = 4 -> 1의 부모는 4 parent[4] = 5
  const move = [];
  //이동 경로를 저장해 두어야하나 각각?
  //퍼지다가 17을 만나서 멈춘건데 -> 역추적해야함.
  //역추적 해야하는 이유 : 1. BFS는 목표지에 도달하기 위해 퍼져나가는 용도 2. 역추적은 왔던길이
  //여기서 질문 역추적 한다고 한들 어떤 길이 정답 길인지 모르지 않나?
  //parent의 용도 : 처음 visited 되었을때의 길을 기억한다. <- 그 길이 곧 최단 거리이기 때문이다.

  //즉, 방문한 이동경로가 아니라 어디서 왔는지 부모 node를 기억하기
  //node(부모) -> next(자식) 을 갈때 visited가 방문하지 않았다면 처음 방문한다는 뜻! -> 최단 거리라는 뜻 : 핵심 포인트
  //때문에 이때 어디서 왔는지 기억하기 .
  //반복이 어려우면 반복할 조각단위로 보기

  queue.push(N);
  visited[N] = true;

  while (queue.length) {
    if (N === K) return "0\n" + N;
    let node = queue.shift();

    if (node === K) break;

    for (let next of [node - 1, node + 1, node * 2]) {
      if (0 <= next && next <= 100000 && !visited[next]) {
        queue.push(next);

        visited[next] = true; //next 개척했구나!
        parent[next] = node; //next의 부모 기억해두기

        dist[next] = dist[node] + 1; //ex ) node = 5 : next = 4 => dist[4] = dist[5](v:0)+1 = 1 이런식으로 돈다는 뜻임. dist[6] = 1 , dist[10] = 1
        if (next === K) {
          let child = next;
          let parentNode = K;
          move.push(parentNode);
          while (child !== N) {
            //parent의 부모의 부모의 부모 찾기 parent[4] = 1 -> parent[1]
            parentNode = parent[child];
            move.push(parentNode);
            child = parentNode;
          }
          return dist[next] + "\n" + move.reverse().join(" ");
        }
      }
    }
  }
}

const [N, K] = input[0].split(" ").map(Number);

console.log(solution(N, K));
```

---

## 🧩 사용된 JS 개념

- 고정 크기 배열 초기화: `Array(100001).fill(...)`
- BFS 큐: `push`, `shift`
- 경로 복원: `parent` 배열 + `reverse()`

---

## 🧩 복잡도

- 시간복잡도 : `O(MAX)` (`MAX = 100000`)
- 공간복잡도 : `O(MAX)`

---

## 🧠 사고 키워드

- 최단거리 + 경로 출력
- BFS 최초 방문 = 최단거리
- parent 역추적

---

## 🔍 트리거 문장

- "가장 빠른 시간" + "이동 경로를 출력"
- "x-1, x+1, 2*x"
- "0 이상 100000 이하"

---

## ⚠️ 오답 포인트

- 경로 출력 문제에서 `parent` 저장을 빼먹으면 복원이 불가능하다.
- `visited` 체크 전에 parent를 덮어쓰면 최단경로 성질이 깨진다.
- 역추적은 `K -> ... -> N` 순서로 모이므로 마지막에 `reverse()`가 필요하다.
- 범위 체크를 빼먹으면 런타임 에러가 난다.
