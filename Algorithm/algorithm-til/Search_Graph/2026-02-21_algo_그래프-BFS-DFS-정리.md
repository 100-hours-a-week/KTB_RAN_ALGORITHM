# 그래프 BFS / DFS 정리

문제 풀이 전에 30초 안에 "DFS로 갈지, BFS로 갈지" 결정하기 위한 실전 정리.

---

## 1) BFS / DFS 선택 기준

### BFS를 먼저 의심할 때

- 최단 거리/최소 이동 횟수
- 단계별(레벨별) 탐색
- "몇 번 만에 도달?"
- 가중치 없는 그래프 최단 경로

### DFS를 먼저 의심할 때

- 연결 요소 개수
- 모든 경로/경우 탐색
- 사이클 판별/그래프 구조 탐색
- 깊게 들어가며 묶음(컴포넌트) 확인

---

## 2) 인접 리스트 vs 인접 행렬

### 인접 리스트 (대부분 추천)

- 연결된 정점만 순회
- 시간복잡도: `O(V + E)`
- 희소 그래프에 유리

### 인접 행렬

- 연결 여부 확인이 빠름: `O(1)`
- 모든 정점 확인이 많아짐: `O(V^2)`
- 노드 수가 작고 행렬 입력이 그대로 주어질 때 사용

### 그래프 팁 (입력 변환)

- 그래프 탐색 문제는 입력 형식을 인접 리스트 또는 인접 행렬로 바꿔서 탐색한다.
- 간선 목록 형태라면 보통 인접 리스트로 바꾸는 것을 추천한다.

예시 입력(간선 목록):

```js
[[1, 2], [2, 5], [5, 1], [3, 4], [4, 6]];
```

인접 리스트 변환 결과:

```js
const graph = [
  [],
  [2, 5],
  [1, 5],
  [4],
  [3, 6],
  [2, 1],
  [4],
];
```

- 인접 리스트를 쓰는 이유는 "연결된 것만" 순회하기 때문이다.
- 인접 행렬은 매번 전체를 돌며 연결 여부를 확인해야 해서 성능이 떨어질 수 있다.

---

## 3) 템플릿

### DFS (재귀)

```js
function dfs(node, graph, visited) {
  visited[node] = true;
  for (const next of graph[node]) {
    if (!visited[next]) dfs(next, graph, visited);
  }
}
```

### BFS (큐)

```js
function bfs(start, graph, visited) {
  const q = [start];
  visited[start] = true;
  let head = 0;

  while (head < q.length) {
    const cur = q[head++];
    for (const next of graph[cur]) {
      if (!visited[next]) {
        visited[next] = true;
        q.push(next);
      }
    }
  }
}
```

---

## 4) 연결 요소 카운팅 공통 패턴

```txt
for i = 1..N:
  if not visited[i]:
    dfs/bfs(i)
    count++
```

`count`가 곧 연결 요소 개수.

---

## 5) 자주 틀리는 포인트

- 무방향 그래프에서 간선을 한쪽만 추가함 (`u->v`만 넣음)
- 방문 처리를 늦게 해서 같은 노드를 중복 삽입함
- 정점 번호가 `1`부터인데 `0`부터 순회함
- 입력이 큰데 `shift()` 큐를 써서 시간초과 발생
- DFS 재귀 깊이 초과를 고려하지 않음 (필요 시 스택 DFS 사용)

---

## 6) 트리거 문장 빠른 매핑

- "최단 거리/최소 횟수" -> BFS
- "연결 요소 개수" -> DFS/BFS 둘 다 가능 (보통 DFS)
- "직접/간접 연결" -> 그래프 + 방문 체크
- "격자(미로/섬)" -> 2D BFS/DFS + 방향 배열 `dx, dy`

---

## 7) 질문 모음 (헷갈린 포인트)

### Q. `visited`는 `Set`으로 해도 되나?

결론:

- 된다.
- 다만 정점 번호가 `1..N`처럼 숫자로 깔끔하게 주어지는 문제에서는 `boolean 배열`이 보통 더 빠르고 단순하다.

왜 그런가:

- `boolean 배열`
  - 인덱스로 바로 접근해서 빠르다.
  - 메모리 크기를 미리 예측하기 쉽다.
  - 코테 그래프 문제의 기본형(`1..N`)에 잘 맞는다.
- `Set`
  - 문자열 노드, 좌표, 범위를 모르는 값에도 바로 쓸 수 있다.
  - 유연하지만, 일반적으로 배열보다 약간 느리고 메모리도 더 쓴다.

빠른 선택 기준:

- 정점이 `1..N`, `0..N-1` -> `visited = Array(n + 1).fill(false)` 추천
- 정점이 문자열/큰 좌표/희소한 값 -> `visited = new Set()` 추천

한 줄 정리:

> 이 문서의 BFS/DFS 기본 템플릿처럼, 번호형 정점 문제는 `boolean 배열`이 정석에 가깝다.

---

## 한 줄 기억법

> 최단거리면 BFS, 묶음 세기면 DFS.  
> 둘 다 결국 "방문 체크 + 인접 정점 순회"다.
