## 🧩 문제

- **문제 제목** : 미로 탐색
- **문제 레벨** : Silver I
- **문제 유형** : BFS, 2차원 격자, 최단거리
- **문제 제공** : BOJ
- **문제 링크** : https://www.acmicpc.net/problem/2178
- **코드 파일** : [maze-search-2178.js](../../algorithm-JS/Search_Graph/maze-search-2178.js)

---

## 🧩 문제 설명

`1`은 갈 수 있는 칸, `0`은 벽이다.  
왼쪽 위 `(0,0)`에서 시작해서 오른쪽 아래 `(N-1,M-1)`까지 간다.  
이때 **최소 몇 칸** 지나가야 도착할 수 있는지 구하는 문제다.

### 문제 유형 정리 세션

- [개념 정리] 그래프 BFS / DFS: [2026-02-21_algo_그래프-BFS-DFS-정리.md](./2026-02-21_algo_그래프-BFS-DFS-정리.md)

### 유형 감지 메모 (최단거리)

- 문제에 `최소 이동`, `최단거리`, `가장 빠르게` 같은 말이 보이면 거리 문제를 먼저 의심한다.
- 한 칸 이동 비용이 전부 같으면 BFS가 정석이다.
- 이 문제는 딱 그 형태라 BFS로 푼다.

---

## 🧩 문제 핵심 포인트

- BFS는 가까운 칸부터 차례대로 퍼져서 본다.
- 그래서 먼저 도착한 경로가 가장 짧다.
- `d[x][y]`에 시작점부터 `(x,y)`까지 걸린 칸 수를 저장한다.
- 이미 간 칸은 `graph[x][y] = 0`으로 바꿔서 다시 안 가게 막는다.

---

## 🧩 내 풀이 방식

- 시작 칸 `(0,0)`을 큐에 넣는다.
- `d[0][0] = 1`로 시작 칸 거리 세팅.
- 큐에서 현재 칸을 꺼내서 상하좌우 4칸을 확인.
- 범위 안이고 값이 `1`이면:
  - 큐에 넣고,
  - 방문 표시(0으로 변경)하고,
  - 거리 `+1` 해서 저장.
- 끝나고 `d[N-1][M-1]`을 반환한다. 값이 0이면 도착 못 한 거라 `-1`.

---

## 🧩 코드 로직 정리

### 전체 흐름

```txt
1. 거리 배열 d 만들기
2. 큐에 시작점 (0,0) 넣기
3. 시작점 거리 1로 기록하고 방문 처리
4. 큐가 빌 때까지 반복
5. 현재 칸에서 4방향 검사
6. 갈 수 있으면 큐 삽입 + 방문 처리 + 거리 갱신
7. 도착 칸 거리 반환 (없으면 -1)
```

### 쉬운 이해 포인트

- BFS는 "물결"처럼 퍼진다.
- 1칸 거리, 2칸 거리, 3칸 거리 순서대로 탐색한다.
- 그래서 도착 칸에 처음 기록된 값이 최소 거리다.

---

## 🧩 코드 구현 (내 풀이)

```js
const fs = require("fs"); // /dev/stdin
const input = fs.readFileSync("../예제.txt").toString().trim().split("\n");

//백준 제출 시
// const fs = require("fs");
// const input = fs.readFileSync(0, "utf-8").trim().split("\n");

function solution(N, M, graph) {
  //거리 기록 용
  let d = Array.from({ length: N }, () => Array(M).fill(0));

  //탐사기록 큐 필요
  let queue = [];
  let head = 0;

  //시작지점
  let start = [0, 0];
  queue.push(start);

  //d(방문 거리용[미래])와 graph(지나쳐온 거리[과거])은 항상 같이 다닌다.
  d[0][0] = 1;
  graph[0][0] = 0; //방문한 곳은 0으로 변경

  const dX = [-1, 0, 1, 0];
  const dY = [0, 1, 0, -1];

  while (head < queue.length) {
    //현재 위치 X,Y : 큐에서 빼기 shift
    let [curX, curY] = queue[head++];

    //상하좌우 탐색 시전
    for (let i = 0; i < 4; i++) {
      let nextX = curX + dX[i];
      let nextY = curY + dY[i];

      if (
        nextX < N &&
        nextX >= 0 &&
        nextY < M &&
        nextY >= 0 &&
        graph[nextX][nextY] === 1
      ) {
        queue.push([nextX, nextY]);
        graph[nextX][nextY] = 0;
        d[nextX][nextY] = d[curX][curY] + 1;
      }
    }
  }

  return d[N - 1][M - 1] || -1;
}

const [N, M] = input[0].split(" ").map(Number);
const graph = input.slice(1).map((i) => [...i].map(Number));

console.log(solution(N, M, graph));
```

---

## 🧩 사용된 JS 개념

- `Array.from` : `N x M` 2차원 배열 만들기
- 큐 + `head` 포인터 : `shift()`보다 빠르게 BFS 돌리기
- 구조분해 할당 : `let [x, y] = ...`

---

## 🧩 복잡도

- 시간복잡도 : `O(N*M)`
- 공간복잡도 : `O(N*M)`

---

## 🧠 사고 키워드

- 최단거리
- 가중치 없음
- 격자 BFS
- 4방향 탐색

---

## 🔍 트리거 문장

- "미로에서 최소 칸 수"
- "상하좌우 이동"
- "시작점에서 도착점까지"

---

## ⚠️ 오답 포인트

- `nextY` 계산에서 `dY` 대신 `dX`를 쓰면 탐색이 틀어진다.
- 방문 체크를 늦게 하면 같은 칸이 큐에 여러 번 들어간다.
- 시작점을 거리 1로 두지 않으면 답이 1씩 어긋날 수 있다.
