## 🧩 문제

* **문제 제목** : 연결 요소의 개수
* **문제 레벨** : Silver II
* **문제 유형** : DFS/BFS, 그래프, 연결 요소
* **문제 제공** : BOJ
* **문제 링크** : https://www.acmicpc.net/problem/11724
* **코드 파일** : [connected-components-11724.js](../../algorithm-JS/Search_Graph/connected-components-11724.js)

---

## 🧩 문제 설명

방향 없는 그래프가 주어질 때, 연결 요소(Connected Component)의 개수를 구하는 문제다.

---

## 🧩 문제 핵심 포인트

* 연결 요소 개수는 `미방문 정점에서 DFS/BFS를 시작한 횟수`와 같다.
* 입력 간선 목록은 탐색 전에 인접 리스트로 변환해 두는 것이 효율적이다.
* 인접 행렬은 매번 전체 정점을 확인해야 해서 불필요한 탐색이 많아진다.

---

## 🧩 내 풀이 방식

* `graph = Array.from({ length: N + 1 }, () => [])`로 인접 리스트를 만든다.
* 간선 `[u, v]`를 양방향으로 추가한다.
* `1..N` 정점을 순회하면서 미방문 정점이면 `dfs(i)` 실행 후 `count++`.
* 순회 종료 후 `count`를 반환한다.

---

## 🧩 코드 로직 정리

### 전체 흐름

```txt
1. N, M 입력 및 간선 파싱
2. 인접 리스트 graph 구성 (양방향)
3. visited 집합 초기화
4. i=1..N 순회
5. 미방문 i에서 dfs(i), count 증가
6. 최종 count 출력
```

---

## 🧩 코드 구현 (내 풀이)

```js
const fs = require("fs");
const input = fs.readFileSync(0, "utf-8").trim().split("\n");

function dfs(start, graph, visited) {
  visited.add(start);

  for (const child of graph[start]) {
    if (!visited.has(child)) dfs(child, graph, visited);
  }
}

function solution(N, M, edge) {
  const graph = Array.from({ length: N + 1 }, () => []);
  const visited = new Set();

  for (const [u, v] of edge) {
    graph[u].push(v);
    graph[v].push(u);
  }

  let count = 0;
  for (let i = 1; i <= N; i++) {
    if (!visited.has(i)) {
      count += 1;
      dfs(i, graph, visited);
    }
  }

  return count;
}

const [N, M] = input[0].split(" ").map(Number);
const edge = input.slice(1, M + 1).map((line) => line.split(" ").map(Number));

console.log(solution(N, M, edge));
```

---

## 🧩 사용된 JS 개념

* `Array.from` : 인접 리스트 초기화
* `Set` : 방문 여부 체크
* 재귀 함수 : DFS 구현

---

## 🧩 복잡도

* 시간복잡도 : `O(N + M)`
* 공간복잡도 : `O(N + M)` (인접 리스트 + 방문 집합)

---

## 🧠 사고 키워드

* 연결 요소
* DFS 탐색
* 인접 리스트

---

## 🔍 트리거 문장

* "방향 없는 그래프"
* "연결 요소의 개수"
* "간접 연결도 같은 그룹"

---

## ⚠️ 오답 포인트

* 간선을 단방향으로만 넣으면 연결 관계가 깨져 오답이 된다.
* 미방문 정점마다 DFS를 새로 시작하지 않으면 컴포넌트 개수가 줄어든다.
* 인덱스 범위를 `0..N-1`로 잘못 잡으면 `1`번 정점 기준 입력에서 오답이 날 수 있다.
