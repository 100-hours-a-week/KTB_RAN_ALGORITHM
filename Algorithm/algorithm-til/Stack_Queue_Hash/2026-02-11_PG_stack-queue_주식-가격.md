## 🧩 문제

* **문제 제목** : 주식 가격
* **문제 레벨** : Level 2
* **문제 유형** : 스택/큐 (Queue, Stack 응용)
* **문제 제공** : Programmers
* **문제 링크** : https://school.programmers.co.kr/learn/courses/30/lessons/42584
* **코드 파일** : [stock-price-42584.js](../../algorithm-JS/1.%20Stack_Queue_Hash/stock-price-42584.js)

---

## 🧩 문제 설명

초 단위로 기록된 주식가격이 담긴 배열 `prices`가 매개변수로 주어질 때, 가격이 떨어지지 않은 기간은 몇 초인지를 `return` 하도록 `solution` 함수를 완성하세요.

---

## 🧩 제한사항

* `prices`의 각 가격은 1 이상 10,000 이하인 자연수입니다.
* `prices`의 길이는 2 이상 100,000 이하입니다.

---

## 🧩 입출력 예

| prices | return |
| --- | --- |
| [1, 2, 3, 2, 3] | [4, 3, 1, 1, 0] |

### 입출력 예 설명

* 1초 시점의 `1`은 끝까지 가격이 떨어지지 않았습니다.
* 2초 시점의 `2`는 끝까지 가격이 떨어지지 않았습니다.
* 3초 시점의 `3`은 1초 뒤에 가격이 떨어집니다. 따라서 1초간 가격이 떨어지지 않은 것으로 봅니다.
* 4초 시점의 `2`는 1초간 가격이 떨어지지 않았습니다.
* 5초 시점의 `3`은 0초간 가격이 떨어지지 않았습니다.

---

## 🧩 문제 핵심 포인트

* 각 시점 `i`에서 가격이 떨어지는 첫 시점까지의 시간을 구한다.
* 떨어지지 않으면 마지막 시점까지의 시간을 구한다.
* `prices.length`가 최대 `100,000`이므로 비효율적인 이중 반복은 부담이 크다.

  - prices[0] → 0초 시점의 가격
  - prices[1] → 1초 시점의 가격

---

## 🧩 내 풀이 방식

코드 주석 기준으로 내가 푼 흐름은 아래와 같음.

* 기준 시점 `i`를 하나 잡는다.
* `i` 뒤의 구간을 순회하면서 초를 `count`로 센다.
* `prices[i] > prices[idx]`가 되는 순간(가격 하락 시점) 멈춘다.
* 멈추기 전까지 센 `count`를 `answer`에 넣는다.
* 모든 시점에 대해 반복한다.

---

## 🧩 코드 로직 정리

### 전체 흐름

```txt
1. i번째 가격을 기준값으로 잡는다.
2. i+1부터 끝까지 보면서 1초씩 count 증가
3. 기준값보다 작은 가격이 나오면 즉시 중단
4. count를 answer에 저장
5. 모든 i에 대해 반복
```

---

## 🧩 코드 구현 (내 풀이)

```js
function solution(prices) {
    let count = 0;
    let answer = [];


    for(let i=0;i<prices.length;i++){
        for(let idx=i;idx<prices.length;idx++){
            if(idx==i) continue;
            count++;

            if(prices[i]>prices[idx]){
                break;
            }

        }
        answer.push(count);
        count=0;

    }



    return answer;
}
```

---

## 🧩 사용된 JS 개념

* `for` 중첩 반복 : 기준 시점 + 이후 구간 탐색
* `break` : 가격 하락 시점에서 즉시 반복 종료
* 배열 `push()` : 시점별 결과 저장

---

## 🧩 코드 리뷰 기반 개선 정리

### 기존 풀이의 장점

* 문제 정의(가격 하락 시점 찾기)를 그대로 구현해 이해하기 쉽다.
* 하락 시점이 나오면 `break`로 멈춰 불필요한 비교를 일부 줄인다.
* 예시 입력 기준으로 동작 흐름이 직관적이다.

### 아쉬운 점과 개선 근거

* 최악의 경우 모든 구간을 이중으로 탐색해 `O(n^2)`가 된다.
* `prices.length`가 최대 `100,000`이므로 시간 초과 위험이 크다.

### 개선 핵심 아이디어 (스택)

* "아직 하락 시점을 못 찾은 인덱스"를 스택에 보관한다.
* 현재 가격이 스택 top 인덱스의 가격보다 작으면, 그 인덱스의 하락 시점이 확정된다.
* 각 인덱스는 스택에 한 번 들어가고 한 번 나오므로 `O(n)`으로 해결 가능하다.

### 개선 코드 예시

```js
function solution(prices) {
  const n = prices.length;
  const answer = Array(n).fill(0);
  const stack = []; // 하락 시점을 아직 못 찾은 인덱스

  for (let i = 0; i < n; i++) {
    while (stack.length > 0 && prices[stack[stack.length - 1]] > prices[i]) {
      const prev = stack.pop();
      answer[prev] = i - prev;
    }
    stack.push(i);
  }

  while (stack.length > 0) {
    const prev = stack.pop();
    answer[prev] = n - 1 - prev;
  }

  return answer;
}
```

### 개선 코드 동작 이해 (스택 관점 상세)

5️⃣ 그래서 stack 안에는 뭐가 들어 있냐면
stack = [0, 1, 3]


이 말은 곧 👇

stack에 들어있는 값	뜻
0	0초 시점 가격은 아직 안 떨어짐
1	1초 시점 가격도 아직 안 떨어짐
3	3초 시점 가격도 아직 안 떨어짐

📌 stack의 값 = prices의 인덱스 = 시점(초)



prices = [1, 2, 3, 2, 3]
어느 순간에:

stack = [0, 1, 2]
i = 3
prices[i] = 2
이 상태는 무슨 뜻이냐면:

0초 가격(1) → 아직 안 떨어짐

1초 가격(2) → 아직 안 떨어짐

2초 가격(3) → 아직 안 떨어짐

지금은 3초 시점이고 가격은 2

그래서:

prices[2] > prices[3]  // 3 > 2
👉 “2초 시점의 가격이 3초에 처음으로 떨어졌구나”

그래서:

answer[2] = 3 - 2



- 시점 = 인덱스 = 초

즉, 이해해보자면

- stack = [0, 1, 3] 이고 지금 i = 5라면, 0, 1, 3은 각각 뭘 의미하는 걸까?

  -> 현재 시점은 5인데 지난 시점들 0초 1초 3초 가격이 아직 떨어지지 않았음.

---

#### 이 문제를 스택으로 푼다는 말의 진짜 뜻

핵심 한 문장

> "아직 언제 떨어질지 모르는 과거 시점들을 보류해 두었다가, 더 싼 가격이 나타나는 순간 한꺼번에 정산한다."

여기서 "보류해 두는 장소"가 바로 스택이다.

#### 스택에는 뭐가 들어가 있나?

```js
const stack = []; // 하락 시점을 아직 못 찾은 인덱스
```

값이 아니라 인덱스를 넣는다.

이유

* 시간 차이(`i - prev`)를 계산해야 하기 때문
- 기존에 사용했던 count++를 제거하고 count를 사용하는 순간 시간복잡도 O(n)을 추가하는 샘
  - 해당 로직을 개선하기 위헤 (떨어진 시점) - (시작 시점)을 계산함.

#### 문제를 스택 관점으로 다시 해석

원래 문제

> 각 시점의 가격이 떨어지지 않은 기간은 몇 초인가?

스택 관점

> 각 시점이 "언제 처음으로 자기보다 싼 값을 만나는가?"

#### 예제로 한 줄 한 줄 따라가기

```js
prices = [1, 2, 3, 2, 3]
index     0  1  2  3  4
```

`i = 0`, 가격 = 1

```js
stack = []
```

* 비교할 과거 없음
* 그냥 보류

```js
stack = [0]
```

`i = 1`, 가격 = 2

```js
prices[stack.top] = prices[0] = 1
1 > 2 ? false
```

* 아직 안 떨어짐
* 보류

```js
stack = [0, 1]
```

`i = 2`, 가격 = 3

```js
prices[1] = 2
2 > 3 ? false
```

```js
stack = [0, 1, 2]
```

`i = 3`, 가격 = 2 (중요 포인트)

```js
prices[2] = 3
3 > 2 ? true
```

2번 인덱스(가격 3)는 여기서 처음으로 떨어진다.

```js
prev = 2
answer[2] = 3 - 2 = 1
```

스택 상태

```js
stack = [0, 1]
```

다시 검사

```js
prices[1] = 2
2 > 2 ? false
```

멈춤 후 현재 인덱스 push

```js
stack = [0, 1, 3]
```

`i = 4`, 가격 = 3

```js
prices[3] = 2
2 > 3 ? false
```

```js
stack = [0, 1, 3, 4]
```

for문 종료 후

스택에 남아 있는 인덱스는 "끝까지 안 떨어진 시점"이다.

```js
while (stack.length > 0) {
  prev = stack.pop();
  answer[prev] = n - 1 - prev;
}
```

계산 결과

| index | 계산 |
| --- | --- |
| 4 | 4 - 4 = 0 |
| 3 | 4 - 3 = 1 |
| 1 | 4 - 1 = 3 |
| 0 | 4 - 0 = 4 |

최종 `answer`

```js
[4, 3, 1, 1, 0]
```

#### 왜 이게 O(n)인가?

"while 있는데 O(n^2) 아닌가요?" 라는 질문이 자주 나오지만, 이 코드는 O(n)이다.

이유

* 각 인덱스는 `push` 1번
* 각 인덱스는 `pop` 1번
* 전체 연산 수는 최대 `2n`

즉 while이 중첩처럼 보여도 총 pop 횟수는 n번이다.

#### 브루트포스와 스택 풀이의 본질 차이

| 브루트포스 풀이 | 스택 풀이 |
| --- | --- |
| 미래를 보며 현재를 판단 | 현재가 과거를 정리 |
| 각 `i`마다 다시 탐색 | 한 번만 순회 |
| 직관적 | 구조적 |
| 입력에 따라 느려짐 | 대용량에서도 안정적 |

#### 핵심 요약

* 스택에는 "아직 답이 안 정해진 인덱스"가 들어간다.
* 더 작은 값이 나오면 그 순간이 답이다.
* 끝까지 더 작은 값이 안 나오면 끝 시점까지의 시간으로 계산한다.

### 기존 vs 개선 비교

| 항목 | 기존 풀이 | 개선 풀이 |
| --- | --- | --- |
| 시간 복잡도 | `O(n^2)` | `O(n)` |
| 자료구조 | 단순 반복 | 스택 |
| 대용량 입력 대응 | 불리함 | 유리함 |
| 구현 난이도 | 쉬움 | 중간 |
