### 🧩문제
- 문제 제목 : 두 줄 대기열에서 짝수번호
- 문제 유형 : 큐
- 문제 제공 : kyo
- 코드파일 : [two-line-queue-even-number.js](../../algorithm-kyo/1.%20Stack_Queue_Hash/two-line-queue-even-number.js)

- 문제 설명
- 두 줄로 나누어 선 사람들이 있습니다. 
첫 번째 줄( queue1 )의 사람들이 앞쪽에 서 있고, 두 번째 줄( queue2 )의 사람들이 그 뒤를 잇고 있습니다.
즉, 두 줄을 이어 붙여 하나의 대기열을 만들면, queue1 의 모든 사람이 먼저 서 있고, 그 다음에 queue2 의 사
람들이 서 있는 상태가 됩니다.

이 합쳐진 대기열에서 맨 앞 사람부터 차례로 검사하며 다음 규칙을 적용합니다:
- 현재 맨 앞 사람이 짝수 번호이면, 그 사람을 뽑아 결과에 추가합니다.
- 홀수 번호이면, 그 사람을 줄 뒤로 보냅니다.
- 이 과정을 반복하여 총 k 명의 짝수 번호 사람을 뽑을 때까지 계속합니다.


- 입력 형식 

    첫번째줄 queue1 , 두번째줄 queue2 , k 명


- 출력 형식

  짝수 번호로 뽑힌 사람들의 번호를 뽑힌 순서대로 배열로 반환합니다.


### 🧩코드 로직
- **내 풀이**
- q1 + q2 합쳤을때, 짝수번째 k를 뽑는다.
1. 합치고
2. 홀수면 버리고 짝수면 result에 넣는다.
3. 조건문 (result.length === k) 이때 반환하도록한다.

```js
function solution(queue1, queue2, k) {
    let result = [];

    let q = [...queue1, ...queue2];
    for (let i = 0; i < q.length; i++) {
        if (q[i] % 2 === 0) {//짝수
            result.push(q[i]);
        }
        if (result.length === k) return result;
    }
    return result;
}
```

- **kyo 풀이**
- 조건문 : result안에 요소가 k보다 작을때까지, 큐에 요소가 남아있을 때까지 반복문이 돌아야된다.
1. 큐의 헤더에서 우선 요소를 뽑는다.
2-1. 해당 요소가 짝수일때 result에 넣고(result.push)
2-2. 아니면 q에 다시 넣는다. (q.push) 

```js
function solution(queue1, queue2, k) {
    let result = [];
    let q = [...queue1, ...queue2];

    while(result.length < k && q.length > 0){
        const person = q.shift();

        if(person %2===0){
            result.push(person);
        }else{
            q.push(person);
        }
    }

    return result;
}
```


### 회고
내 풀이와 쿄풀이가 완전히 다르고 내 풀이는 filter에 관점에서, 쿄풀이는 문제 그대로의 구현에 가깝다.
그렇다면 코테는 결과만 맞히는 문제가 아니라 큐의 상태 변화 과정을 정확히 시뮬레이션 하는 문제이다.
단순 순회가 아니라 큐연산 기반 풀이가 필요하다

- 코테는 문제를 풀수만있다면 어떠한 경로로 풀었는지는 상관이 없지 않을까? 

    코테도 문제 의도대로 풀어야 한다.
-> 기술면접에서 코테에 대해 물어볼 수 있기 때문에...
나같이 풀면 기술면
접에서 답변할 수 없다고 함... 

- 모든 코테가 자료구조 문제는 아니지만
모든 코테는 "자료구조를 써서 구현"하게 되어있다. 고 한다.