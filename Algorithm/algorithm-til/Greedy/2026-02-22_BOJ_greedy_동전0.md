## 🧩 문제

* **문제 제목** : 동전 0
* **문제 레벨** : Silver IV
* **문제 유형** : 그리디 (Greedy)
* **문제 제공** : BOJ
* **문제 링크** : https://www.acmicpc.net/problem/11047
* **코드 파일** : [11047.js](../../algorithm-JS/Greedy/11047.js)

---

## 🧩 문제 설명

`N`종류의 동전이 주어지고, 목표 금액 `K`를 만들어야 한다.  
각 동전은 무한히 사용할 수 있을 때, 동전 개수의 최솟값을 구하는 문제다.

---

## 🧩 문제 핵심 포인트

* 큰 단위 동전부터 최대한 사용하는 그리디가 정답이 된다.
* 이 문제는 동전 단위가 그리디가 성립하도록 주어지는 유형이다.
* 각 동전에 대해 `K / coin` 개수를 바로 계산하면 된다.

---

## 🧩 내 풀이 방식

* 동전 배열을 큰 값부터 순회한다.
* 현재 동전으로 만들 수 있는 최대 개수 `Math.floor(money / coin)`를 구한다.
* 개수만큼 답에 더하고, 사용한 금액만큼 `money`에서 뺀다.
* 남은 금액이 0이 될 때까지 반복한다.

---

## 🧩 코드 로직 정리

### 전체 흐름

```txt
1. n, money, 동전 배열 입력
2. 가장 큰 동전부터 역순 순회
3. 현재 동전 사용 가능 개수 계산
4. count 누적, money 감소
5. 순회 종료 후 count 반환
```

---

## 🧩 코드 구현 (내 풀이)

```js
const fs = require("fs");
const input = fs.readFileSync(0, "utf-8").trim().split("\n");

function solution(n, money, kindOfMoney) {
  let count = 0;

  for (let i = n - 1; i >= 0; i--) {
    if (money >= kindOfMoney[i]) {
      const currentCount = Math.floor(money / kindOfMoney[i]);
      count += currentCount;
      money -= kindOfMoney[i] * currentCount;
    }
  }

  return count;
}

const [n, money] = input[0].split(" ").map(Number);
const kindOfMoney = input.slice(1, n + 1).map(Number);

console.log(solution(n, money, kindOfMoney));
```

---

## 🧩 사용된 JS 개념

* `Math.floor()` : 현재 동전으로 만들 수 있는 최대 개수 계산
* 배열 역순 순회 : 큰 단위부터 그리디 적용
* `map(Number)` : 문자열 입력을 숫자로 변환

---

## 🧩 복잡도

* 시간복잡도 : `O(N)`
* 공간복잡도 : `O(1)` (입력 저장 제외)

---

## 🧠 사고 키워드

* 큰 단위 우선
* 최소 개수
* 그리디 성립 조건

---

## 🔍 트리거 문장

* "동전 개수의 최솟값"
* "동전은 여러 개 사용할 수 있다"
* "큰 단위부터 선택"

---

## ⚠️ 오답 포인트

* 입력 동전을 문자열 상태로 두면 비교/연산에서 오류가 난다.
* 작은 동전부터 순회하면 최소 개수를 보장하지 못한다.
* 이분탐색처럼 범위를 나누는 문제가 아니라, 선택 순서가 핵심인 그리디 문제다.
