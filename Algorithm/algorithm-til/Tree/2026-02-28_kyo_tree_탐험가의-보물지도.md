## 🧩 문제

* **문제 제목** : 탐험가의 보물지도
* **문제 레벨** : 강의 문제집
* **문제 유형** : 트리, BST 삽입, 전위/후위 순회
* **문제 제공** : Inflearn Kyo
* **문제 링크** : 강의 문제집 내 제공 문제
* **코드 파일** : [treasure-map-tree-traversal-kyo.js](../../algorithm-JS/Tree/treasure-map-tree-traversal-kyo.js)

---

## 🧩 문제 설명

각 노드는 `[x, y]` 좌표로 주어진다.  
`y`가 큰 노드부터 트리를 만들고, 삽입은 `x` 기준으로 왼쪽/오른쪽을 결정한다.  
완성된 이진트리의 전위 순회 결과와 후위 순회 결과를 노드 번호 배열로 반환한다.

---

## 🧩 문제 핵심 포인트

* 입력 순서를 보존하기 위해 각 노드에 `index(1-base)`를 붙여야 한다.
* `y` 내림차순 정렬 후 순서대로 삽입해야 부모-자식 높이 관계가 유지된다.
* 삽입 기준은 `x` 값 비교이며, 순회는 재귀 DFS로 처리한다.

---

## 🧩 내 풀이 방식

* `treasureLocations.map((node, i) => [...node, i + 1])`로 인덱스를 추가한다.
* `y` 기준 내림차순으로 정렬한 뒤, BST 삽입 규칙(`x` 비교)으로 트리를 만든다.
* 루트 기준 `preOrder(CLR)`와 `postOrder(LRC)`를 실행해 결과 배열을 만든다.

---

## 🧩 코드 로직 정리

### 전체 흐름

```txt
1. 각 노드에 원래 번호(index)를 붙인다.
2. y 내림차순으로 정렬한다.
3. 정렬된 노드를 x 비교로 BST에 삽입한다.
4. 전위 순회(CLR) 결과를 preArr에 저장한다.
5. 후위 순회(LRC) 결과를 postArr에 저장한다.
6. [preArr, postArr]를 반환한다.
```

---

## 🧩 코드 구현 (내 풀이)

```js
class Node {
  constructor(index, xpos) {
    this.xpos = xpos;
    this.index = index;
    this.left = null;
    this.right = null;
  }
}

class BinaryTree {
  constructor() {
    this.root = null;
    this.preArr = []; // 전위 탐색 배열 CLR
    this.postArr = []; // 후위 탐색 배열 LRC
  }

  insert(index, xpos) {
    const newNode = new Node(index, xpos);

    if (!this.root) {
      this.root = newNode;
      return;
    }

    let currentNode = this.root;

    while (true) {
      if (xpos < currentNode.xpos) {
        if (!currentNode.left) {
          currentNode.left = newNode;
          return;
        }
        currentNode = currentNode.left;
      } else {
        if (!currentNode.right) {
          currentNode.right = newNode;
          return;
        }
        currentNode = currentNode.right;
      }
    }
  }

  // CLR
  preOrder(node) {
    if (node) {
      this.preArr.push(node.index);
      this.preOrder(node.left);
      this.preOrder(node.right);
    }
  }

  // LRC
  postOrder(node) {
    if (node) {
      this.postOrder(node.left);
      this.postOrder(node.right);
      this.postArr.push(node.index);
    }
  }
}

function solution(treasureLocations) {
  const tree = new BinaryTree();
  const sortedNodes = treasureLocations
    .map((node, i) => [...node, i + 1])
    .sort((a, b) => b[1] - a[1]);

  sortedNodes.forEach((node) => {
    const [xpos, , index] = node;
    tree.insert(index, xpos);
  });

  tree.preOrder(tree.root);
  tree.postOrder(tree.root);

  return [tree.preArr, tree.postArr];
}
```

---

## 🧩 사용된 JS 개념

* `class` : `Node`, `BinaryTree` 구조화
* `Array.prototype.map()` : 노드 번호(index) 부여
* `Array.prototype.sort()` : `y` 기준 내림차순 정렬
* 재귀 함수 : 전위/후위 순회 구현

---

## 🧩 복잡도

* 시간복잡도 : 평균 `O(n log n)` (정렬 + 평균 삽입), 최악 `O(n^2)` (편향 트리)
* 공간복잡도 : `O(n)` (트리 노드 + 순회 결과 배열)

---

## 🧠 사고 키워드

* 좌표 -> 트리 재구성
* 높이(`y`) 우선 정렬
* `x` 기준 BST 삽입
* DFS 전위/후위 순회

---

## 🔍 트리거 문장

* "좌표로 주어진 노드로 트리를 구성한다."
* "전위 순회, 후위 순회 결과를 구하라."
* "부모는 자식보다 위(y가 큼)에 있다."

---

## ⚠️ 오답 포인트

* `y` 정렬 없이 입력 순서대로 삽입하면 트리 구조가 달라진다.
* 원래 노드 번호(index)를 저장하지 않으면 정답 형식을 맞출 수 없다.
* `x` 비교 분기를 반대로 두면 전위/후위 결과가 전부 틀어진다.

