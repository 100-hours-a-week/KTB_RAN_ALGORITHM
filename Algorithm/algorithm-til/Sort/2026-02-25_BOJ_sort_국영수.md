## 🧩 문제

* **문제 제목** : 국영수
* **문제 레벨** : Silver IV
* **문제 유형** : 정렬 (Sort), 다중 조건 정렬
* **문제 제공** : BOJ
* **문제 링크** : https://www.acmicpc.net/problem/10825
* **코드 파일** : [korean-english-math-10825.js](../../algorithm-JS/Sort/korean-english-math-10825.js)

---

> ⚠️ 필수 메모: 코테 제출 환경에서는 `localeCompare` 대신 `return a.name < b.name ? -1 : 1`로 이름 tie-breaker를 명시하는 방식을 우선 사용한다.

## 🧩 문제 설명

학생의 이름과 국어/영어/수학 점수가 주어진다.  
정렬 기준은 다음과 같다.

* 국어 점수 내림차순
* 국어가 같으면 영어 점수 오름차순
* 국어/영어가 같으면 수학 점수 내림차순
* 세 점수가 모두 같으면 이름 사전순 오름차순

최종 정렬된 순서대로 이름을 출력하면 된다.

---

## 🧩 문제 핵심 포인트

* **필수 메모(앞단 고정)** : 제출 환경에서 `localeCompare`가 기대와 다르게 동작해 오답이 난 경우가 있었고, 이름 비교는 `return a.name < b.name ? -1 : 1` 형태로 처리하는 편이 안전했다.
* 다중 정렬 문제는 비교 우선순위를 정확히 계층화해야 한다.
* 마지막 이름 비교까지 포함되므로 숫자 조건이 모두 같은 분기를 반드시 넣어야 한다.

---

## 🧩 내 풀이 방식

* 입력 배열을 `{ name, K, E, M }` 객체 배열로 변환한다.
* `sort` comparator에서 문제의 우선순위를 위에서부터 차례대로 구현한다.
* 정렬 결과에서 이름만 추출해 줄바꿈으로 반환한다.

---

## 🧩 코드 로직 정리

### 전체 흐름

```txt
1. 학생 정보를 객체 배열로 변환한다.
2. K, E, M, name 우선순위대로 comparator를 작성한다.
3. 정렬된 배열에서 name만 추출한다.
4. 줄바꿈 문자열로 출력한다.
```

---

## 🧩 코드 구현 (내 풀이)

```js
const fs = require("fs"); // /dev/stdin
const input = fs.readFileSync("../예제.txt").toString().trim().split("\n");

//백준 제출 시
// const fs = require("fs");
// const input = fs.readFileSync(0, "utf-8").trim().split("\n");

function solution(arr) {
  let students = [];
  for (let i of arr) {
    let student = {};
    student.name = i[0];
    student.K = i[1];
    student.E = i[2];
    student.M = i[3];
    students.push(student);
  }

  //정렬 시도
  students.sort((a, b) => {
    if (a.K === b.K && b.E === a.E && a.M === b.M)
      return a.name < b.name ? -1 : 1;
    if (a.K === b.K && b.E === a.E) return b.M - a.M;
    if (b.K === a.K) return a.E - b.E;

    return b.K - a.K;
  });
  return students.map((i) => i.name).join("\n");
}

const arr = input
  .slice(1)
  .map((i) => i.split(" ").map((i) => (!isNaN(Number(i)) ? Number(i) : i)));
console.log(solution(arr));
```

---

## 🧩 사용된 JS 개념

* `Array.prototype.sort((a, b) => ...)` : 다중 조건 comparator 구현
* 객체 배열 : 학생별 속성을 구조적으로 저장
* `map()`, `join("\n")` : 출력 형식 생성

---

## 🧩 복잡도

* 시간복잡도 : `O(N log N)` (정렬)
* 공간복잡도 : `O(N)` (학생 객체 배열)

---

## 🧠 사고 키워드

* 다중 정렬 기준
* comparator 우선순위
* tie-breaker

---

## 🔍 트리거 문장

* "점수 여러 개 기준 정렬"
* "같으면 다음 기준 적용"
* "이름 사전순"

---

## ⚠️ 오답 포인트

* 조건 순서를 잘못 두면 우선순위가 뒤집혀 오답이 난다.
* 이름 tie-breaker에서 비교식을 명확히 음수/양수로 반환하지 않으면 의도와 다른 순서가 나올 수 있다.
* 숫자/문자 파싱이 섞인 입력에서 타입 변환을 놓치면 비교가 깨진다.
