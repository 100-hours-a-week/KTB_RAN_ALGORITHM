## 🧩 문제

* **문제 제목** : 최대부분 증가 수열 (LIS)
* **문제 레벨** : 강의 문제집
* **문제 유형** : DP (Bottom-up), 이중 반복문
* **문제 제공** : Inflearn Kyo
* **문제 링크** : 강의 문제집 내 제공 문제
* **코드 파일** : [lis-kyo.js](../../algorithm-JS/DP/lis-kyo.js)

---

## 🧩 문제 설명

배열 `arr`가 주어질 때,  
원소의 순서를 유지하면서 값이 strictly increasing(엄격 증가)하는 부분수열 중  
가장 긴 길이를 구한다.

예시) `arr = [10, 20, 10, 30, 20, 50]`  
가능한 LIS 예: `[10, 20, 30, 50]` -> 길이 `4`

---

## 🧩 문제 핵심 포인트

* 이 문제는 `최장 길이`를 구하는 전형적인 `LIS DP` 유형이다.
* `dp[i]`를 "i를 마지막 원소로 하는 LIS 길이"로 두면 점화식이 단순해진다.
* `arr[j] < arr[i]`인 이전 원소들만 후보가 되며, 그중 최댓값을 이어붙인다.
* 점화식: `dp[i] = max(dp[i], dp[j] + 1)` (`j < i`, `arr[j] < arr[i]`)

---

## 🧩 내 풀이 방식

* `dp`를 전부 `1`로 초기화한다. (자기 자신만 뽑아도 길이 1)
* `target`을 1부터 끝까지 이동하며, 왼쪽 구간 `0..target-1`을 모두 확인한다.
* 증가 조건(`arr[j] < arr[target]`)을 만족하면 `dp[target]`을 갱신한다.
* 최종 정답은 `Math.max(...dp)`다.

---

## 🧩 코드 로직 정리

### 문제 유형 판단법

```txt
1. "부분수열" + "증가" + "가장 긴/최대 길이" 키워드가 보인다.
2. 각 위치를 끝으로 하는 최적값을 누적해서 만든다.
3. 이전 상태(j)에서 현재(i)로 전이하는 DP를 떠올린다.
```

### 수도코드

```txt
dp를 길이 n, 모든 값 1로 초기화

for i = 1..n-1:
  for j = 0..i-1:
    if arr[j] < arr[i]:
      dp[i] = max(dp[i], dp[j] + 1)

정답 = dp의 최댓값
```

### 전체 흐름

```txt
1. dp[i] 의미 정의: i에서 끝나는 LIS 길이
2. dp 초기값 1 설정
3. 이중 반복으로 j -> i 전이 검사
4. 증가 조건이면 dp[i] 갱신
5. dp 최댓값 반환
```

---

## 🧩 코드 구현 (내 풀이)

```js
function solution(arr) {
  // dp[i] = i번째 원소를 "반드시 포함"하는 LIS 길이
  // 초기값 1: 자기 자신만 선택하는 부분수열은 항상 가능
  const n = arr.length;
  const dp = Array(n).fill(1);

  // target 위치를 끝으로 하는 LIS를 왼쪽 원소들(j)로 확장
  for (let target = 1; target < n; target++) {
    for (let j = 0; j < target; j++) {
      // 증가 조건을 만족하면, 더 긴 길이로 갱신
      if (arr[j] < arr[target]) {
        dp[target] = Math.max(dp[target], dp[j] + 1);
      }
    }
  }

  // 전체 LIS는 각 위치를 끝으로 하는 값들 중 최대
  return Math.max(...dp);
}
```

---

## 🧩 사용된 JS 개념

* `Array(n).fill(1)` : DP 초기화
* 이중 `for`문 : 모든 `(j, i)` 전이 확인
* `Math.max()` : 최적값 갱신 및 최종 정답 계산

---

## 🧩 복잡도

* 시간복잡도 : `O(n^2)` (이중 반복문)
* 공간복잡도 : `O(n)` (`dp` 배열)

---

## 🧠 사고 키워드

* LIS
* "i에서 끝나는 최적해" 상태 정의
* 이전 원소에서 현재 원소로 전이
* Bottom-up DP

---

## 🔍 트리거 문장

* "가장 긴 증가하는 부분수열"
* "순서는 유지, 일부만 선택"
* "최대 길이"

---

## ⚠️ 오답 포인트

* `dp[i]` 의미를 모호하게 두면 점화식이 꼬인다.
* `arr[j] <= arr[i]`로 쓰면 엄격 증가 조건이 깨질 수 있다.
* `dp` 초기값을 `0`으로 두면 길이 계산이 1씩 모자랄 수 있다.

