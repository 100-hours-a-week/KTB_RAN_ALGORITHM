## DP 동적프로그래밍
작은 부분 문제의 답을 이용해 전체 문제를 해결하는 방법
→ 큰문제를 작은 문제로 쪼개어 문제를 해결한다.
---
- 조건
  - 중복되는 부분 문제
    - 큰 문제와 작은 문제를 같은 방법으로 풀 수 있다. → 주로 재귀 사용 
  - 최적 부분 구조 
    - 정답을 구했다면 메모이제이션 → 한번 구한 결과는 저장해서 다시 계산하지 않는다.
- 구현 방식
  - top-down : 재귀 호출 + 결과 저장(메모이제이션)
  - bottom-up : 작은 문제에서 부터 반복문으로 해결
---
### 💡 예제 : 피보나치 수열 [top down]
```javascript
const memo = {} //값을 저장할 memo 객체

function fibonacci(n){
  if(n<=1) return n;

  if(memo[n]) return memo[n];//이미 계산된 값이라면 값을 반환

  memo[n] = fibonacci(n-1) + fibonacci(n-2) // 재귀 호출 + 결과 저장
  return memo[n];
}
```

[bottom up]
```javascript
function fibonacci(n){
  if(n<=1) return n;

  //값을 저장할 dp 배열
  const dp = Array(n+1).fill(0);
  dp[0] = 0;
  dp[1] = 1; //작은 문제 두개 풀고 : 기저값

  for(let i=2;i<=n;i++){
    dp[i]=dp[i-1]+dp[i-2]; //그 다음 작은 문제는 2니까 2부터 n까지 증가
  }

  return dp[n];
}
```

---
### DP 푸는 방법
1. 상태 정의
  ```javascript
dp[i] = i번째까지 고려했을 때의 최적값
  ```
2. 점화식
  ```javascript
dp[i] = dp[i-1] + dp[i-2]
  ```
3. 작은 값을 먼저 풀어두기.
  ```javascript
dp[0] = ...
dp[1] = ...
  ```
4. 값이 있으면 계산하지 않도록한다 (제일 중요)
---
### DP를 보고 떠올려야하는 생각
> DP는 규칙찾기.
1. i번째에서 뭘 할수있지?
2. 그 선택을 하려면 이전에 어떤 상태여야하지?
→ 반복

### 점화식 세우는 공식 절차
> 요약
> 1. dp의 의미를 먼저 정의
> 2. i번째에서 내가할수있는 선택
> 3. 선택마다 이전 상태가 뭐였는지 찾는다.
> 4. 최적을 고른다.

> 무조건 이 순서로 강행해
1. dp의 의미를 먼저 정의
  → dp\[i\]가 정확히 뭘 의미하는지 문장으로 쓰는 연습
```javascript
dp[i] = i번째 집까지 고려했을 때 최대 돈
dp[i] = i번째 원소를 마지막으로 하는 LIS 길이
```

1. i번째에서 내가할수있는 선택
  → DP는 미래 예측이 아닌, 현재에서 가능한 선택지를 나눈다.
- DP는 항상 선택한다!!
```javascript
도둑문제 :
- 털지 않는다.
- 턴다

LIS 문제 :
- 연결한다.
- 연결하지 않는다.
```

1. 선택마다 이전 상태가 뭐였는지 찾는다.
→ 점화식 등장
```javascript
도둑문제 :
- 안턴다 - dp[i-1]
- 턴다 - dp[i-2]+money[i]
```

1. 최적을 고른다.
- 최대 : Math.max
- 최소 : Math.min
---
### DP 유형 핵심
1. 선형 DP
  dp\[i\] = i번째까지의 최적값
  이전 몇 칸만 참고 (i-1, i-2 등)
  예: 계단, 도둑, 연속합
2. 부분 수열 DP
  dp\[i\] = i를 마지막으로 하는 최적 수열
  i 이전 원소들과 비교
  예: LIS
3. 배낭 DP
  dp\[i\]\[w\] = i번째까지 고려했을 때 무게 w의 최적값
  선택 / 미선택 구조
  예: 0-1 Knapsack, 동전
4. 문자열 DP
  dp\[i\]\[j\] = i, j 위치까지 고려한 결과
  2차원 비교 구조
  예: LCS, 편집 거리
5. 구간 DP
  dp\[l\]\[r\] = 구간 l~r의 최적값
  구간을 나눠 계산
  예: 행렬 곱셈, 파일 합치기
6. 트리 DP
  dp\[node\]\[state\]
  DFS + 선택 상태 분리
7. 비트마스크 DP
  dp\[mask\]\[i\]
  방문 집합을 비트로 표현
### 실전에서 자주 나오는 유형
1. 선형 DP
2. 부분 수열 DP (LIS 계열)
3. 배낭 문제
4. 문자열 DP
5. 구간 DP
