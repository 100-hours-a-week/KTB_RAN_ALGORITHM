## 🧩 문제

* **문제 제목** : 1, 2, 3 더하기
* **문제 레벨** : 실버 3
* **문제 유형** : DP (Bottom-up), 경우의 수
* **문제 제공** : BOJ 9095
* **문제 링크** : https://www.acmicpc.net/problem/9095
* **코드 파일** : [sum-1-2-3-9095.js](../../algorithm-JS/DP/sum-1-2-3-9095.js)

---

## 🧩 문제 설명

정수 `n`을 `1`, `2`, `3`의 합으로 나타내는 방법의 수를 구한다.  
합을 나타낼 때는 수를 1개 이상 사용해야 한다.

예시) `n=4`인 경우 7가지
`1+1+1+1`, `1+1+2`, `1+2+1`, `2+1+1`, `2+2`, `1+3`, `3+1`

---

## 🧩 문제 핵심 포인트

* `dp[i]`를 "i를 만드는 방법의 수"로 두면, 마지막에 붙는 수(1/2/3) 기준으로 분해된다.
* `i`를 만드는 방법은:
  * `i-1` 뒤에 `+1` 붙이기
  * `i-2` 뒤에 `+2` 붙이기
  * `i-3` 뒤에 `+3` 붙이기
* 점화식:
  * `dp[i] = dp[i-1] + dp[i-2] + dp[i-3]`

---

## 🧩 내 풀이 방식

* 기저값을 먼저 고정한다.
  * `dp[1]=1`, `dp[2]=2`, `dp[3]=4`
* `i=4`부터 `n`까지 `dp[i-1]`, `dp[i-2]`, `dp[i-3]`를 더해 채운다.
* 입력은 여러 테스트케이스이므로 각 `n`마다 `solution(n)` 출력한다.

---

## 🧩 코드 로직 정리

### 전체 흐름

```txt
1. dp[i] 의미 정의: i를 만드는 방법의 수
2. 기저값 dp[1]=1, dp[2]=2, dp[3]=4 세팅
3. i=4..n 반복
4. dp[i] = dp[i-1] + dp[i-2] + dp[i-3]
5. dp[n] 반환
```

---

## 🧩 코드 구현 (내 풀이)

```js
// 정수 4를 1, 2, 3의 합으로 나타내는 방법은 총 7가지가 있다. 합을 나타낼 때는 수를 1개 이상 사용해야 한다.
//
// 1+1+1+1
// 1+1+2
// 1+2+1
// 2+1+1
// 2+2
// 1+3
// 3+1
// 정수 n이 주어졌을 때, n을 1, 2, 3의 합으로 나타내는 방법의 수를 구하는 프로그램을 작성하시오.
//1, 2, 3의 합
//
//1. dp의 정의
//dp[i] = i를 만들 수 있는 방법의 수
//
//2. i번째에 내가 할 수 있는 선택
//현재 dp만 생각하기
//마지막에 1,2,3을 붙여 i를 만드는 경우
//
//점화식
//dp[i] = dp[i-1] + dp[i-2] + dp[i-3]

const fs = require("fs"); // /dev/stdin
const input = fs.readFileSync("../예제.txt").toString().trim().split("\n");

//백준 제출 시
// const fs = require("fs");
// const input = fs.readFileSync(0, "utf-8").trim().split("\n");

function solution(n) {
  const dp = Array(n + 1).fill(0);

  if (n === 0) return 0;
  if (n === 1) return 1;
  if (n === 2) return 2;
  if (n === 3) return 4;

  dp[1] = 1;
  dp[2] = 2;
  dp[3] = 4;

  for (let i = 4; i <= n; i++) {
    for (let j = 1; j <= 3; j++) {
      dp[i] += dp[i - j];
    }
  }
  return dp[n];
}

const n = input.slice(1).map(Number);

for (const i of n) {
  console.log(solution(i));
}
```

---

## 🧩 사용된 JS 개념

* `Array(n + 1).fill(0)` : DP 배열 초기화
* 중첩 반복문 : `i`마다 `1,2,3` 선택 누적
* `for...of` : 테스트케이스 순회 출력

---

## 🧩 복잡도

* 시간복잡도 : `O(n)` (상수 3회 연산 누적)
* 공간복잡도 : `O(n)`

---

## 🧠 사고 키워드

* 경우의 수 DP
* 마지막 선택 분해
* 점화식
* Bottom-up

---

## 🔍 트리거 문장

* "1,2,3의 합으로 나타내는 방법의 수"
* "방법의 수 / 경우의 수"
* "여러 테스트케이스"

---

## ⚠️ 오답 포인트

* `dp[i]`를 "연산 횟수"로 정의하면 문제가 어긋난다. (정답은 "방법의 수")
* 기저값 `dp[1], dp[2], dp[3]`을 잘못 두면 전부 틀어진다.
* 여러 테스트케이스 입력에서 첫 줄(`T`)을 제외하지 않으면 오답이 난다.

---

## 📝 회고 KPT

### 🟢 Keep

* DP 문제에서 **상태 정의(`dp[i]`의 의미)**를 먼저 잡으려고 시도했다.
* 작은 `n`(4, 5)을 직접 써보면서 패턴을 찾으려 했다.
* 점화식을 코드로 여러 번 실험하며 구조를 이해하려 했다.

### 🔴 Problem

* “경우의 수” 문제인데도 `+1`, `+3`처럼 숫자를 더하는 방식으로 접근했다.
* `dp[i]`를 “방법의 수”가 아니라 “연산 횟수”로 오해했다.
* 점화식을 세우기 전에 `dp`의 정의가 정확하지 않았다.
* `dp[0]`의 의미를 이해하지 못해 베이스 케이스에서 혼란이 있었다.
* 점화식에서 `dp[i] += dp[i-j] + 1`처럼 경우의 수와 실제 숫자를 혼동했다.

### 🟡 Try

* 앞으로 DP 문제는 반드시 다음 순서로 접근한다.
  * `dp[i]`의 정확한 의미를 한 문장으로 정의
  * 작은 `n`을 직접 써보고 패턴 확인
  * “마지막 선택” 기준으로 점화식 세우기
  * 베이스 케이스가 점화식과 논리적으로 맞는지 검증
* `dp[0]`은 “아무것도 선택하지 않은 한 가지 경우”라는 개념을 기억한다.
* 점화식에 숫자 상수(`+1`, `+3` 등)가 들어가면 한 번 더 의심한다.
