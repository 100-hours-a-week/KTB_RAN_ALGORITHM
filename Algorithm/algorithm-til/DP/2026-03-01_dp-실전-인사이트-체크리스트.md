# DP 실전 인사이트 체크리스트

## 1) DP 시작 10초: 이 문장부터 쓴다

```text
dp[상태] = 상태를 만족할 때의 최적값(또는 경우의 수)
```

이 한 줄이 안 써지면 아직 DP가 아니라 문제 해석 단계이다.

예시

- `dp[i] = i번째까지 고려했을 때 최대 합`
- `dp[i] = i에서 끝나는 LIS 길이`
- `dp[i][j] = a의 i번째, b의 j번째까지 고려했을 때 최적값`
- `dp[mask][i] = 방문 집합이 mask이고 현재 i일 때 최적값`

---

## 2) 점화식은 “현재 선택”과 “직전 상태”로 만든다

DP는 항상 아래 두 질문으로 세운다.

- 지금 상태에서 가능한 선택은 무엇인가?
- 그 선택을 하려면 직전에 어떤 상태였어야 하는가?

이걸 식으로 바꾸면 점화식이다.

```text
dp[cur] = best( dp[prev1] + cost1, dp[prev2] + cost2, ... )
```

`best`는 문제 목표에 따라 `max`, `min`, `sum` 중 하나다.

---

## 3) 트리거 문장으로 DP 감지하기

문제에서 아래 표현이 보이면 DP 가능성을 먼저 연다.

- “최대/최소를 구하라”
- “경우의 수를 구하라”
- “연속/부분수열/구간”
- “앞에서부터 i번째까지”
- “한 번 계산한 걸 다시 쓰면 이득”

---

## 4) 유형별 상태 정의 템플릿

### 선형 DP

```text
dp[i] = i번째(또는 i번째까지) 최적값
```

예: 계단, 도둑, 연속합

### LIS/부분수열 DP

```text
dp[i] = i를 마지막 원소로 할 때 최적 길이/값
```

예: LIS, 바이토닉

### 배낭류 DP

```text
dp[i][w] = 앞 i개 물건으로 무게 w에서의 최적값
```

예: 0/1 배낭, 동전 문제

### 문자열 DP

```text
dp[i][j] = 문자열 a,b의 prefix(i,j) 기준 최적값
```

예: LCS, 편집 거리

### 구간 DP

```text
dp[l][r] = 구간 l~r의 최적값
```

예: 행렬 곱셈 순서, 파일 합치기

---

## 5) 기저값은 “더 못 쪼개는 최소 단위”로 둔다

점화식보다 기저값이 더 자주 틀린다.

- 최소 길이 입력(`n=0`, `n=1`)을 먼저 종이에 써본다.
- 점화식에서 참조하는 가장 작은 인덱스를 기준으로 초기값을 채운다.
- 1-index/0-index를 초반에 고정한다.

---

## 6) 구현 순서 (실전 루틴)

1. 상태 문장을 쓴다.
2. 현재 선택을 나눈다.
3. 각 선택의 직전 상태를 연결한다.
4. 점화식을 만든다.
5. 기저값을 채운다.
6. 작은 상태부터 큰 상태 순서로 채운다.
7. 정답 상태(`dp[n]`, `max(dp)`, `dp[n][m]`)를 확인한다.

---

## 7) 자주 하는 실수

- `dp[i]` 의미가 문제 중간에 바뀜
- 점화식은 맞는데 기저값 누락
- 순회 방향이 점화식 의존성과 반대
- “정답이 dp[n]인지, 배열 전체 max인지”를 혼동
- 메모이제이션 키를 불완전하게 잡음(2차원 문제를 1차원 키로 저장)

---

## 8) 빠른 점검 질문

- “내 `dp` 문장을 보고 제3자가 의미를 정확히 이해할 수 있는가?”
- “현재 선택이 빠짐없이 분기되었는가?”
- “각 분기가 유효한 이전 상태와 연결되었는가?”
- “기저값이 점화식 참조 범위를 모두 커버하는가?”
- “최종 반환 상태가 문제 요구와 정확히 일치하는가?”
