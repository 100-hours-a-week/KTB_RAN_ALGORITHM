## 🧩 문제

* **문제 제목** : 카드 정렬하기
* **문제 레벨** : Gold 4
* **문제 유형** : 힙/우선순위 큐 (Heap, Priority Queue), Greedy
* **문제 제공** : BOJ
* **문제 링크** : https://www.acmicpc.net/problem/1715
* **코드 파일** : [1715.js](../../algorithm-JS/Heap_PriorityQueue/1715.js)

---

## 🧠 문제 키워드

* 사용 알고리즘 : 최소 힙(우선순위 큐) + 그리디
* 가장 작은 두 묶음 반복 병합
* 병합 비용 누적 최소화
* 정렬 반복 대신 힙으로 최소값 추출
* `n`이 큰 입력에서 `O(n log n)` 유지

---

## 🧩 문제 설명

카드 묶음이 여러 개 주어질 때, 두 묶음을 합칠 때마다 비교 횟수는 두 묶음 크기의 합이다.
모든 묶음을 하나로 합칠 때 필요한 총 비교 횟수의 최솟값을 구하는 문제다.

---

## 🧩 제한사항

* `1 ≤ N ≤ 100,000`
* 카드 묶음 크기: `1` 이상 `1,000` 이하

---

## 🧩 입출력 예

| 입력 | 출력 |
| --- | --- |
| 3 / 10 / 20 / 40 | 100 |

### 입출력 예 설명

* 10 + 20 = 30 (비용 30)
* 30 + 40 = 70 (비용 70)
* 총 비용 = 30 + 70 = 100

---

## 🧩 문제 핵심 포인트

* 매 단계에서 가장 작은 두 묶음을 먼저 합쳐야 전체 비용이 최소가 된다.
* "최소값 2개 반복 추출" 구조이므로 최소 힙이 가장 적합하다.
* 묶음이 하나뿐이면 비교할 필요가 없어서 답은 `0`이다.

---

## 🧩 내 풀이 방식

* 모든 카드 묶음을 최소 힙에 넣는다.
* 힙에서 가장 작은 값 두 개를 꺼내 합친다.
* 합친 값을 정답(`total`)에 더하고 다시 힙에 넣는다.
* 힙 크기가 1이 될 때까지 반복한다.

---

## 🧩 코드 로직 정리

### 전체 흐름

```txt
1. N이 1 이하이면 0 반환
2. 모든 카드 묶음을 최소 힙에 삽입
3. 힙 크기가 1보다 큰 동안:
   3-1. 최소값 두 개 추출
   3-2. 두 값 합(sum) 계산
   3-3. total += sum
   3-4. sum을 힙에 재삽입
4. total 반환
```

---

## 🧩 코드 구현 (내 풀이)

```js
const fs = require("fs");
const input = fs.readFileSync(0, "utf-8").trim().split("\n");

class MinHeap {
  constructor() {
    this.heap = [];
  }

  size() {
    return this.heap.length;
  }

  insert(value) {
    const heap = this.heap;
    heap.push(value);
    this.heapifyUp();
  }

  extractMin() {
    const heap = this.heap;
    if (heap.length === 0) return null;
    if (heap.length === 1) return heap.pop();

    const min = heap[0];
    heap[0] = heap.pop();
    this.heapifyDown();
    return min;
  }

  heapifyUp() {
    const heap = this.heap;
    let currentIndex = heap.length - 1;

    while (currentIndex > 0) {
      const parentIndex = Math.floor((currentIndex - 1) / 2);
      if (heap[parentIndex] <= heap[currentIndex]) break;

      const swap = heap[parentIndex];
      heap[parentIndex] = heap[currentIndex];
      heap[currentIndex] = swap;
      currentIndex = parentIndex;
    }
  }

  heapifyDown() {
    const heap = this.heap;
    let currentIndex = 0;

    while (true) {
      const leftChildIndex = currentIndex * 2 + 1;
      const rightChildIndex = currentIndex * 2 + 2;
      let minIndex = currentIndex;

      if (
        leftChildIndex < heap.length &&
        heap[leftChildIndex] < heap[minIndex]
      ) {
        minIndex = leftChildIndex;
      }
      if (
        rightChildIndex < heap.length &&
        heap[rightChildIndex] < heap[minIndex]
      ) {
        minIndex = rightChildIndex;
      }

      if (minIndex === currentIndex) break;

      const swap = heap[minIndex];
      heap[minIndex] = heap[currentIndex];
      heap[currentIndex] = swap;
      currentIndex = minIndex;
    }
  }
}

function solution(n, cards) {
  if (n <= 1) return 0;

  const minHeap = new MinHeap();
  let total = 0;

  for (const card of cards) {
    minHeap.insert(card);
  }

  while (minHeap.size() > 1) {
    const first = minHeap.extractMin();
    const second = minHeap.extractMin();
    const sum = first + second;

    total += sum;
    minHeap.insert(sum);
  }

  return total;
}

const n = Number(input[0]);
const cards = input.slice(1).map(Number);
console.log(solution(n, cards));
```

---

## 🧩 시행착오 및 수정 사항

### 1) 정렬 반복으로 접근

초기에는 "정렬 -> 최소 2개 꺼내기 -> 다시 정렬" 방식이 떠오름.

문제:

* 반복 정렬은 `O(n log n)`이 계속 발생해 전체가 비효율적

수정:

* 최소값 2개 추출이 핵심이므로 최소 힙으로 전환

### 2) `N = 1` 예외 케이스 누락

문제:

* 카드 묶음이 하나면 비교 자체가 없는데 반복 로직을 타면 불필요한 처리 발생

수정:

* `if (n <= 1) return 0` 예외 처리 추가

### 3) 힙 구현 시 인덱스/스왑 실수 가능성

문제:

* `heapifyUp`, `heapifyDown`에서 인덱스 갱신이 틀리면 힙 불변식이 깨짐

수정:

* 부모/자식 인덱스 계산과 swap 순서를 고정 패턴으로 유지

---

## 🧩 사용된 JS 개념

* `class` : 최소 힙 구현
* `for...of` : 카드 묶음 순회
* `fs.readFileSync(0, "utf-8")` : BOJ 표준 입력 처리
* 사용자 정의 자료구조 연산 (`insert`, `extractMin`)

---

## 🧩 복잡도

* 시간복잡도 : `O(n log n)`
* 공간복잡도 : `O(n)`

---

## 🧠 사고 키워드

* 가장 작은 두 개 반복 선택
* 누적 비용 최소화
* 정렬 반복 대신 우선순위 큐
* 그리디 + 힙 결합

---

## 🔍 트리거 문장

* "가장 작은 두 묶음을 계속 합친다."
* "병합 비용의 총합을 최소화한다."

---

## ⚠️ 오답 포인트

* 배열 정렬을 매 반복마다 수행하면 성능이 급격히 나빠진다.
* `N = 1` 처리 누락 시 불필요 연산 또는 예외가 발생할 수 있다.
* 힙 구현에서 부모/자식 인덱스 계산 실수는 바로 오답으로 이어진다.
