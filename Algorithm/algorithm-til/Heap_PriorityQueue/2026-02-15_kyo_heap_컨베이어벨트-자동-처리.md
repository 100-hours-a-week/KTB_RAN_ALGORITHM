## 🧩 문제

* **문제 제목** : 컨베이어벨트 자동 처리
* **문제 레벨** : -
* **문제 유형** : 힙/우선순위 큐 (Heap, Priority Queue)
* **문제 제공** : kyo
* **문제 링크** : 강의 문제
* **코드 파일** : [conva.js](../../algorithm-JS/Heap_PriorityQueue/conva.js)

---

## 🧠 문제 키워드

* 사용 알고리즘 : 우선순위 큐(최소 힙) + 그리디
* 최대 `R`개 면제(자동 처리) 관리
* 현재까지 구간 중 큰 값 `R`개를 선택
* 힙 크기 초과 시 최소값을 실제 소요 시간에 반영
* prefix(앞에서부터) 최대 길이 탐색

---

## 🧩 문제 설명

컨베이어벨트 구간별 처리 시간이 `times`로 주어진다.

* 총 작업 가능 시간은 `T`
* 자동 처리 모드 사용 가능 횟수는 `R`
* 자동 처리 모드는 처리 시간이 가장 큰 구간에 쓰면 그 시간만큼 소요 시간을 0으로 만들 수 있다.

물품은 순서대로 처리해야 하며, 작업 시간 합이 `T`를 넘지 않게 처리 가능한 최대 구간 수를 구하는 문제다.

---

## 🧩 제한사항

* `1 ≤ T ≤ 1,000,000,000`
* `1 ≤ R ≤ 500,000`
* `1 ≤ times.length ≤ 1,000,000`
* `1 ≤ times[i] ≤ 1,000,000`

---

## 🧩 입출력 예

| T | R | times | result |
| --- | --- | --- | --- |
| 12 | 2 | [6, 3, 5, 8, 2, 4] | 5 |
| 5 | 3 | [10, 20, 30] | 3 |

### 입출력 예 설명

* 예시 1: 자동 처리 모드를 큰 값(예: 6, 8)에 쓰면 실제 소요 시간은 `3 + 5 + 2 = 10`이 되어 5개를 처리할 수 있다.
* 예시 2: 3개 모두 자동 처리 모드를 쓸 수 있어 모든 구간 처리 가능하다.

---

## 🧩 문제 핵심 포인트

* 각 시점에서 자동 처리 모드는 "지금까지 본 구간 중 가장 큰 `R`개"에 적용하는 것이 최적이다.
* 즉, 지금까지 본 값 중 큰 `R`개를 따로 보관하고 나머지만 실제 시간으로 누적하면 된다.
* 큰 `R`개를 유지하려면 최소 힙을 쓰는 게 효율적이다.

---

## 🧩 내 풀이 방식

* `minHeap`에 현재까지 본 처리 시간을 넣는다.
* 힙 크기가 `R`을 초과하면 `extractMin()`으로 가장 작은 값을 꺼내 `usedTime`에 더한다.
* 이렇게 하면 힙에는 항상 "자동 처리 대상으로 남겨둔 큰 값 `R`개"만 남는다.
* 매 단계 `usedTime > T`면 더 진행 불가이므로 중단하고 현재까지 개수를 반환한다.

---

## 🧩 코드 로직 정리

### 전체 흐름

```txt
1. 최소 힙(minHeap), usedTime, count 초기화
2. times를 앞에서부터 순회
3. 현재 time을 힙에 삽입
4. 힙 크기가 R보다 크면 최소값을 꺼내 usedTime에 더함
5. usedTime > T 이면 중단
6. 아니면 count 증가
7. count 반환
```

---

## 🧩 코드 구현 (내 풀이)

```js
class MinHeap {
  constructor() {
    this.heap = [];
  }

  size() {
    return this.heap.length;
  }

  insert(value) {
    this.heap.push(value);
    this.heapifyUp();
  }

  extractMin() {
    if (this.heap.length === 0) return null;
    if (this.heap.length === 1) return this.heap.pop();

    const min = this.heap[0];
    this.heap[0] = this.heap.pop();
    this.heapifyDown();
    return min;
  }

  swap(i, j) {
    [this.heap[i], this.heap[j]] = [this.heap[j], this.heap[i]];
  }

  heapifyUp() {
    let currentIndex = this.heap.length - 1;
    while (currentIndex > 0) {
      const parentIndex = Math.floor((currentIndex - 1) / 2);
      if (this.heap[parentIndex] <= this.heap[currentIndex]) break;
      this.swap(currentIndex, parentIndex);
      currentIndex = parentIndex;
    }
  }

  heapifyDown() {
    const length = this.heap.length;
    let currentIndex = 0;

    while (true) {
      let minIndex = currentIndex;
      const leftChildIndex = 2 * currentIndex + 1;
      const rightChildIndex = 2 * currentIndex + 2;

      if (
        leftChildIndex < length &&
        this.heap[leftChildIndex] < this.heap[minIndex]
      ) {
        minIndex = leftChildIndex;
      }

      if (
        rightChildIndex < length &&
        this.heap[rightChildIndex] < this.heap[minIndex]
      ) {
        minIndex = rightChildIndex;
      }

      if (minIndex === currentIndex) break;
      this.swap(currentIndex, minIndex);
      currentIndex = minIndex;
    }
  }
}

function solution(T, R, times) {
  const minHeap = new MinHeap();
  let usedTime = 0;
  let count = 0;

  for (const time of times) {
    minHeap.insert(time);

    if (minHeap.size() > R) {
      usedTime += minHeap.extractMin();
    }

    if (usedTime > T) break;
    count += 1;
  }

  return count;
}
```

---

## 🧩 사용된 JS 개념

* `class` : 힙 자료구조 구현
* `for...of` : 배열 순차 순회
* 구조 분해 할당 : `swap` 구현
* 사용자 정의 최소 힙 연산 (`insert`, `extractMin`)

---

## 🧩 복잡도

* 시간복잡도 : `O(n log R)` (`n = times.length`)
* 공간복잡도 : `O(R)` (힙 크기 최대 `R + 1`)

---

## 🧠 사고 키워드

* 가장 큰 값 `R`개 유지
* 남는 값만 누적 시간
* 순차 처리(prefix) 최대 길이
* 힙으로 동적 최댓값 집합 관리

---

## 🔍 트리거 문장

* "상위 K개를 제외하고 나머지 합을 관리한다."
* "순서대로 처리하면서 조건(`<= T`)을 만족하는 최대 개수를 구한다."

---

## ⚠️ 오답 포인트

* `times.shift()`를 쓰면 `O(n^2)`가 되어 큰 입력에서 느려질 수 있다.
* 자동 처리 대상을 고정해두면 최적 해를 놓친다. (매 단계 재선택 필요)
* 힙 크기 조건을 `> R`로 관리하지 않으면 누적 시간이 잘못 계산된다.
