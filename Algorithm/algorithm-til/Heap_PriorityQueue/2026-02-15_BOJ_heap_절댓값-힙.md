## 🧩 문제

* **문제 제목** : 절댓값 힙
* **문제 레벨** : Silver 1
* **문제 유형** : 힙/우선순위 큐 (Heap, Priority Queue)
* **문제 제공** : BOJ
* **문제 링크** : https://www.acmicpc.net/problem/11286
* **코드 파일** : [11286.js](../../algorithm-JS/Heap_PriorityQueue/11286.js)

---

## 🧠 문제 키워드

* 사용 알고리즘 : 사용자 정의 비교 함수를 가진 최소 힙
* 우선순위 1순위: 절댓값이 작은 값
* 우선순위 2순위: 절댓값이 같으면 실제 값이 작은 값
* 삽입/추출 연산 반복
* `0` 명령 시 빈 힙 예외 처리

---

## 🧩 문제 설명

비어 있는 배열에서 연산을 수행한다.

* `x != 0` : 배열에 `x` 삽입
* `x == 0` : 절댓값이 가장 작은 값을 출력하고 제거  
  (절댓값이 같으면 더 작은 수 출력)
* 힙이 비어 있는데 `0`이면 `0` 출력

---

## 🧩 제한사항

* `1 ≤ N ≤ 100,000`
* 입력 정수는 `-2^31 < x < 2^31`

---

## 🧩 입출력 예

| 입력 | 출력 |
| --- | --- |
| 18 / 1 / -1 / 0 / 0 / 0 / 1 / 1 / -1 / -1 / 2 / -2 / 0 / 0 / 0 / 0 / 0 / 0 / 0 | -1 / 1 / 0 / -1 / -1 / 1 / 1 / -2 / 2 / 0 |

---

## 🧩 문제 핵심 포인트

* 일반 최소 힙이 아니라 "비교 기준이 2단계"인 힙이다.
* 루트 판단은 `compare(a,b)` 함수로 통일해야 구현 실수를 줄일 수 있다.
* 삽입/삭제 모두 `O(log n)`이므로 `N=100,000`에서도 안정적이다.

---

## 🧩 내 풀이 방식

* `compare(a,b)`를 아래 기준으로 구현:
  * `|a| !== |b|`면 `|a| - |b|`
  * 같으면 `a - b`
* `heapifyUp/Down`에서 모두 `compare`를 사용한다.
* `0` 명령이면:
  * 힙이 비었으면 `0`
  * 아니면 `extractMin()` 결과 출력 배열에 추가

---

## 🧩 코드 로직 정리

### 전체 흐름

```txt
1. AbsMinHeap 생성
2. 명령 x를 순서대로 처리
3. x == 0:
   - 힙 비어있으면 0 추가
   - 비어있지 않으면 extractMin() 추가
4. x != 0:
   - 힙에 삽입
5. 출력 배열을 줄바꿈으로 출력
```

---

## 🧩 코드 구현 (내 풀이)

```js
const fs = require("fs");
const input = fs.readFileSync(0, "utf-8").trim().split("\n");

class AbsMinHeap {
  constructor() {
    this.heap = [];
  }

  size() {
    return this.heap.length;
  }

  compare(a, b) {
    if (Math.abs(a) === Math.abs(b)) return a - b;
    return Math.abs(a) - Math.abs(b);
  }

  insert(value) {
    const heap = this.heap;
    heap.push(value);
    this.heapifyUp();
  }

  extractMin() {
    const heap = this.heap;
    if (heap.length === 0) return null;
    if (heap.length === 1) return heap.pop();

    const min = heap[0];
    heap[0] = heap.pop();
    this.heapifyDown();
    return min;
  }

  heapifyUp() {
    const heap = this.heap;
    let currentIndex = heap.length - 1;

    while (currentIndex > 0) {
      const parentIndex = Math.floor((currentIndex - 1) / 2);
      if (this.compare(heap[parentIndex], heap[currentIndex]) <= 0) break;

      const temp = heap[parentIndex];
      heap[parentIndex] = heap[currentIndex];
      heap[currentIndex] = temp;
      currentIndex = parentIndex;
    }
  }

  heapifyDown() {
    const heap = this.heap;
    let currentIndex = 0;

    while (true) {
      const leftChildIndex = currentIndex * 2 + 1;
      const rightChildIndex = currentIndex * 2 + 2;
      let minIndex = currentIndex;

      if (
        leftChildIndex < heap.length &&
        this.compare(heap[leftChildIndex], heap[minIndex]) < 0
      ) {
        minIndex = leftChildIndex;
      }
      if (
        rightChildIndex < heap.length &&
        this.compare(heap[rightChildIndex], heap[minIndex]) < 0
      ) {
        minIndex = rightChildIndex;
      }

      if (minIndex === currentIndex) break;

      const temp = heap[minIndex];
      heap[minIndex] = heap[currentIndex];
      heap[currentIndex] = temp;
      currentIndex = minIndex;
    }
  }
}

function solution(n, arr) {
  const heap = new AbsMinHeap();
  const answer = [];

  for (const x of arr) {
    if (x === 0) {
      if (heap.size() === 0) answer.push(0);
      else answer.push(heap.extractMin());
    } else {
      heap.insert(x);
    }
  }

  return answer;
}

const n = Number(input[0]);
const arr = input.slice(1).map(Number);
console.log(solution(n, arr).join("\n"));
```

---

## 🧩 시행착오 및 수정 사항

### 1) 로컬 파일 입력 사용

기존:

```js
fs.readFileSync("../예제.txt")
```

문제:

* BOJ 제출 환경에서는 표준 입력을 읽어야 함

수정:

```js
fs.readFileSync(0, "utf-8")
```

### 2) 절댓값 동률 처리 누락 위험

문제:

* 절댓값만 비교하면 `-1`과 `1` 우선순위를 구분 못 함

수정:

* `Math.abs(a) === Math.abs(b)`일 때 `a - b`로 tie-break

### 3) 힙 구현에서 비교 기준 혼용

문제:

* 일부는 일반 숫자 비교, 일부는 절댓값 비교로 섞이면 힙 불변식이 깨짐

수정:

* `heapifyUp/Down` 모두 `compare()`만 사용

---

## 🧩 사용된 JS 개념

* `class` : 사용자 정의 우선순위 힙 구현
* `Math.abs()` : 절댓값 기준 비교
* `fs.readFileSync(0, "utf-8")` : 표준 입력 처리
* `join("\n")` : 다중 라인 출력 포맷

---

## 🧩 복잡도

* 시간복잡도 : `O(N log N)`
* 공간복잡도 : `O(N)`

---

## 🧠 사고 키워드

* 커스텀 비교 함수
* 절댓값 기준 우선순위
* tie-break 조건 설계
* 삽입/삭제 `log n`

---

## 🔍 트리거 문장

* "절댓값이 가장 작은 값을 꺼낸다."
* "동점이면 더 작은 수를 먼저 꺼낸다."

---

## ⚠️ 오답 포인트

* tie-break(절댓값 같을 때 실제 값 비교) 누락
* `0` 명령에서 빈 힙 처리 누락
* 입력 경로를 로컬 파일로 두고 제출
