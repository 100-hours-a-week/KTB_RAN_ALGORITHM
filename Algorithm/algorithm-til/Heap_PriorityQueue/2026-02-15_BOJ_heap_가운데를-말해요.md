## ğŸ§© ë¬¸ì œ

* **ë¬¸ì œ ì œëª©** : ê°€ìš´ë°ë¥¼ ë§í•´ìš”
* **ë¬¸ì œ ë ˆë²¨** : Gold 2
* **ë¬¸ì œ ìœ í˜•** : í™/ìš°ì„ ìˆœìœ„ í (Heap, Priority Queue), ìŠ¤íŠ¸ë¦¬ë° ì¤‘ì•™ê°’
* **ë¬¸ì œ ì œê³µ** : BOJ
* **ë¬¸ì œ ë§í¬** : https://www.acmicpc.net/problem/1655
* **ì½”ë“œ íŒŒì¼** : [1655.js](../../algorithm-JS/Heap_PriorityQueue/1655.js)

---

## ğŸ§  ë¬¸ì œ í‚¤ì›Œë“œ

* ì‚¬ìš© ì•Œê³ ë¦¬ì¦˜ : ë‘ í™(MaxHeap + MinHeap)
* ë°ì´í„° ìŠ¤íŠ¸ë¦¼ ì¤‘ì•™ê°’ ìœ ì§€
* ì™¼ìª½ í™ í¬ê¸° >= ì˜¤ë¥¸ìª½ í™ í¬ê¸° ìœ ì§€
* ì™¼ìª½ ìµœëŒ€ê°’ <= ì˜¤ë¥¸ìª½ ìµœì†Œê°’ ìœ ì§€
* ë§¤ ì…ë ¥ë§ˆë‹¤ ì¤‘ì•™ê°’ ì¦‰ì‹œ ì¶œë ¥

---

## ğŸ§© ë¬¸ì œ ì„¤ëª…

ì •ìˆ˜ê°€ í•˜ë‚˜ì”© ë“¤ì–´ì˜¬ ë•Œë§ˆë‹¤ í˜„ì¬ê¹Œì§€ ìˆ˜ë“¤ì˜ ì¤‘ì•™ê°’ì„ ì¶œë ¥í•˜ëŠ” ë¬¸ì œë‹¤.

ë¬¸ì œ ì •ì˜ìƒ ì›ì†Œ ê°œìˆ˜ê°€ ì§ìˆ˜ì¼ ë•ŒëŠ” ê°€ìš´ë° ë‘ ê°’ ì¤‘ ì‘ì€ ê°’ì„ ì¤‘ì•™ê°’ìœ¼ë¡œ ì‚¬ìš©í•œë‹¤.

---

## ğŸ§© ì œí•œì‚¬í•­

* `1 â‰¤ N â‰¤ 100,000`
* ì…ë ¥ ì •ìˆ˜ëŠ” ë²”ìœ„ ë‚´ ì •ìˆ˜
* ë§¤ ì…ë ¥ë§ˆë‹¤ ë°”ë¡œ ì¤‘ì•™ê°’ ì¶œë ¥ í•„ìš”

---

## ğŸ§© ì…ì¶œë ¥ ì˜ˆ

| ì…ë ¥ | ì¶œë ¥ |
| --- | --- |
| 7 / 1 / 5 / 2 / 10 / -99 / 7 / 5 | 1 / 1 / 2 / 2 / 2 / 2 / 5 |

---

## ğŸ§© ë¬¸ì œ í•µì‹¬ í¬ì¸íŠ¸

* ì „ì²´ë¥¼ ë§¤ë²ˆ ì •ë ¬í•˜ë©´ `O(n log n)`ì´ ëˆ„ì ë˜ì–´ ë¹„íš¨ìœ¨ì ì´ë‹¤.
* ì¤‘ì•™ê°’ë³´ë‹¤ ì‘ì€ ì ˆë°˜ì€ MaxHeap, í° ì ˆë°˜ì€ MinHeapìœ¼ë¡œ ê´€ë¦¬í•œë‹¤.
* ì¤‘ì•™ê°’ì€ í•­ìƒ MaxHeap ë£¨íŠ¸(ì™¼ìª½ ì ˆë°˜ì˜ ìµœëŒ€ê°’)ë¡œ ê²°ì •í•  ìˆ˜ ìˆë‹¤.

---

## ğŸ§© ë‚´ í’€ì´ ë°©ì‹

* `x <= maxHeap.peek()`ì´ë©´ ì™¼ìª½(MaxHeap), ì•„ë‹ˆë©´ ì˜¤ë¥¸ìª½(MinHeap)ì— ì‚½ì…
* í™ í¬ê¸° ê· í˜• ì¡°ì •:
  * `maxHeap.size() < minHeap.size()`ë©´ ì˜¤ë¥¸ìª½ì—ì„œ í•˜ë‚˜ ì˜®ê¹€
  * `maxHeap.size() > minHeap.size() + 1`ë©´ ì™¼ìª½ì—ì„œ í•˜ë‚˜ ì˜®ê¹€
* ìˆœì„œ ë³´ì •:
  * `maxHeap.peek() > minHeap.peek()`ë©´ ë£¨íŠ¸ë¼ë¦¬ êµí™˜
* ë§¤ ë‹¨ê³„ ì¤‘ì•™ê°’ì€ `maxHeap.peek()`

---

## ğŸ§© ì½”ë“œ ë¡œì§ ì •ë¦¬

### ì „ì²´ íë¦„

```txt
1. MaxHeap(ì™¼ìª½), MinHeap(ì˜¤ë¥¸ìª½) ì¤€ë¹„
2. ìˆ«ì xë¥¼ ì…ë ¥ë°›ì•„ ê¸°ì¤€ì— ë”°ë¼ ì–‘ìª½ í™ ì¤‘ í•˜ë‚˜ì— ì‚½ì…
3. ë‘ í™ì˜ í¬ê¸° ê· í˜• ë§ì¶¤ (ì™¼ìª½ì´ ê°™ê±°ë‚˜ 1ê°œ ë§ê²Œ)
4. ì™¼ìª½ ë£¨íŠ¸ > ì˜¤ë¥¸ìª½ ë£¨íŠ¸ë©´ ë£¨íŠ¸ êµí™˜ìœ¼ë¡œ ìˆœì„œ ë³´ì •
5. ì™¼ìª½ ë£¨íŠ¸ë¥¼ ì¤‘ì•™ê°’ìœ¼ë¡œ ì¶œë ¥ ë°°ì—´ì— ì¶”ê°€
6. ëª¨ë“  ì…ë ¥ ì²˜ë¦¬ í›„ ì¤„ë°”ê¿ˆ ì¶œë ¥
```

---

## ğŸ§© ì½”ë“œ êµ¬í˜„ (ë‚´ í’€ì´)

```js
const fs = require("fs");
const input = fs.readFileSync(0, "utf-8").trim().split("\n").map(Number);

class MaxHeap {
  constructor() {
    this.heap = [];
  }

  size() {
    return this.heap.length;
  }

  peek() {
    return this.heap.length ? this.heap[0] : null;
  }

  insert(value) {
    const heap = this.heap;
    heap.push(value);
    this.heapifyUp();
  }

  extractMax() {
    const heap = this.heap;
    if (heap.length === 0) return null;
    if (heap.length === 1) return heap.pop();

    const max = heap[0];
    heap[0] = heap.pop();
    this.heapifyDown();
    return max;
  }

  heapifyUp() {
    const heap = this.heap;
    let currentIndex = heap.length - 1;

    while (currentIndex > 0) {
      const parentIndex = Math.floor((currentIndex - 1) / 2);
      if (heap[parentIndex] >= heap[currentIndex]) break;

      const tmp = heap[parentIndex];
      heap[parentIndex] = heap[currentIndex];
      heap[currentIndex] = tmp;
      currentIndex = parentIndex;
    }
  }

  heapifyDown() {
    const heap = this.heap;
    let currentIndex = 0;

    while (true) {
      const leftChildIndex = currentIndex * 2 + 1;
      const rightChildIndex = currentIndex * 2 + 2;
      let maxIndex = currentIndex;

      if (leftChildIndex < heap.length && heap[leftChildIndex] > heap[maxIndex]) {
        maxIndex = leftChildIndex;
      }
      if (rightChildIndex < heap.length && heap[rightChildIndex] > heap[maxIndex]) {
        maxIndex = rightChildIndex;
      }

      if (maxIndex === currentIndex) break;

      const tmp = heap[maxIndex];
      heap[maxIndex] = heap[currentIndex];
      heap[currentIndex] = tmp;
      currentIndex = maxIndex;
    }
  }
}

class MinHeap {
  constructor() {
    this.heap = [];
  }

  size() {
    return this.heap.length;
  }

  peek() {
    return this.heap.length ? this.heap[0] : null;
  }

  insert(value) {
    const heap = this.heap;
    heap.push(value);
    this.heapifyUp();
  }

  extractMin() {
    const heap = this.heap;
    if (heap.length === 0) return null;
    if (heap.length === 1) return heap.pop();

    const min = heap[0];
    heap[0] = heap.pop();
    this.heapifyDown();
    return min;
  }

  heapifyUp() {
    const heap = this.heap;
    let currentIndex = heap.length - 1;

    while (currentIndex > 0) {
      const parentIndex = Math.floor((currentIndex - 1) / 2);
      if (heap[parentIndex] <= heap[currentIndex]) break;

      const tmp = heap[parentIndex];
      heap[parentIndex] = heap[currentIndex];
      heap[currentIndex] = tmp;
      currentIndex = parentIndex;
    }
  }

  heapifyDown() {
    const heap = this.heap;
    let currentIndex = 0;

    while (true) {
      const leftChildIndex = currentIndex * 2 + 1;
      const rightChildIndex = currentIndex * 2 + 2;
      let minIndex = currentIndex;

      if (leftChildIndex < heap.length && heap[leftChildIndex] < heap[minIndex]) {
        minIndex = leftChildIndex;
      }
      if (rightChildIndex < heap.length && heap[rightChildIndex] < heap[minIndex]) {
        minIndex = rightChildIndex;
      }

      if (minIndex === currentIndex) break;

      const tmp = heap[minIndex];
      heap[minIndex] = heap[currentIndex];
      heap[currentIndex] = tmp;
      currentIndex = minIndex;
    }
  }
}

function solution(n, arr) {
  const maxHeap = new MaxHeap();
  const minHeap = new MinHeap();
  const answer = [];

  for (const x of arr) {
    if (maxHeap.size() === 0 || x <= maxHeap.peek()) maxHeap.insert(x);
    else minHeap.insert(x);

    if (maxHeap.size() < minHeap.size()) {
      maxHeap.insert(minHeap.extractMin());
    }
    if (maxHeap.size() > minHeap.size() + 1) {
      minHeap.insert(maxHeap.extractMax());
    }

    if (minHeap.size() > 0 && maxHeap.peek() > minHeap.peek()) {
      const a = maxHeap.extractMax();
      const b = minHeap.extractMin();
      maxHeap.insert(b);
      minHeap.insert(a);
    }

    answer.push(maxHeap.peek());
  }

  return answer;
}

const n = input[0];
const arr = input.slice(1, n + 1);
console.log(solution(n, arr).join("\n"));
```

---

## ğŸ§© ì‹œí–‰ì°©ì˜¤ ë° ìˆ˜ì • ì‚¬í•­

### 1) ë¡œì»¬ ì…ë ¥ íŒŒì¼ ê²½ë¡œ ì‚¬ìš©

ê¸°ì¡´:

```js
fs.readFileSync("../ì˜ˆì œ.txt")
```

ë¬¸ì œ:

* BOJ í™˜ê²½ì—ì„œ ì…ë ¥ì„ ì½ì§€ ëª»í•¨

ìˆ˜ì •:

```js
fs.readFileSync(0, "utf-8")
```

### 2) ì¤‘ì•™ê°’ì„ "ì™„ì „ ê· í˜• BST" ë¬¸ì œë¡œ ì˜¤í•´

ë¬¸ì œ:

* íŠ¸ë¦¬ ë†’ì´ ê· í˜• ìì²´ë¥¼ ë§ì¶”ë ¤ëŠ” ê´€ì ìœ¼ë¡œ ê°€ë©´ êµ¬í˜„ì´ ê³¼í•´ì§

ìˆ˜ì •:

* ë‘ í™ìœ¼ë¡œ "ì¤‘ì•™ ê²½ê³„"ë§Œ ìœ ì§€
  * `left size >= right size`
  * `max(left) <= min(right)`

### 3) í¬ê¸° ê· í˜•ë§Œ ë§ì¶”ê³  ìˆœì„œ ë³´ì • ëˆ„ë½

ë¬¸ì œ:

* íŠ¹ì • ì…ë ¥ ìˆœì„œì—ì„œ `maxHeap.peek() > minHeap.peek()`ê°€ ë˜ì–´ ì¤‘ì•™ê°’ ì˜¤ë‹µ ê°€ëŠ¥

ìˆ˜ì •:

* ë£¨íŠ¸ ë¹„êµ í›„ í•„ìš” ì‹œ êµí™˜ ë¡œì§ ì¶”ê°€

---

## ğŸ§© ì‚¬ìš©ëœ JS ê°œë…

* `class` : MaxHeap/MinHeap êµ¬í˜„
* `fs.readFileSync(0, "utf-8")` : í‘œì¤€ ì…ë ¥
* `join("\n")` : ëŒ€ëŸ‰ ì¶œë ¥ ì²˜ë¦¬
* ì¡°ê±´ ê¸°ë°˜ ì¬ê· í˜• ë¡œì§

---

## ğŸ§© ë³µì¡ë„

* ì‹œê°„ë³µì¡ë„ : `O(N log N)`
* ê³µê°„ë³µì¡ë„ : `O(N)`

---

## ğŸ§  ì‚¬ê³  í‚¤ì›Œë“œ

* streaming median
* ë‘ í™ ê²½ê³„ ìœ ì§€
* í¬ê¸° ê· í˜• + ìˆœì„œ ê· í˜•
* ì¤‘ì•™ê°’ ì¦‰ì‹œ ì¡°íšŒ

---

## ğŸ” íŠ¸ë¦¬ê±° ë¬¸ì¥

* "ìˆ˜ì—´ì´ í•˜ë‚˜ì”© ë“¤ì–´ì˜¬ ë•Œë§ˆë‹¤ ì¤‘ì•™ê°’ ì¶œë ¥"
* "ì‹¤ì‹œê°„ìœ¼ë¡œ ì¤‘ì•™ê°’ ìœ ì§€"

---

## âš ï¸ ì˜¤ë‹µ í¬ì¸íŠ¸

* í™ í¬ê¸° ê· í˜•ë§Œ ë§ì¶”ê³  ë£¨íŠ¸ ìˆœì„œ ë³´ì • ëˆ„ë½
* ì¤‘ì•™ê°’ì„ `minHeap` ë£¨íŠ¸ë¡œ ì˜ëª» ì¶œë ¥
* ì…ë ¥/ì¶œë ¥ ìµœì í™” ë¯¸í¡ìœ¼ë¡œ ì‹œê°„ ì´ˆê³¼

---

## ğŸ§© ê°œë… ì •ë¦¬: BSTì²˜ëŸ¼ ë³´ì´ì§€ë§Œ ë‘ í™ì´ ì •ë‹µì¸ ì´ìœ 

ì´ ë¬¸ì œëŠ” ê· í˜• BSTë¡œë„ ì ‘ê·¼ ê°€ëŠ¥í•œ "ì¤‘ì•™ê°’ ìœ ì§€ ë¬¸ì œ"ì§€ë§Œ,
ì½”í…Œì—ì„œëŠ” êµ¬í˜„ ë‚œì´ë„ì™€ ì•ˆì •ì„±ì„ ê³ ë ¤í•´ ë‘ í™ì´ ìµœì ì´ë‹¤.

í•µì‹¬ì€ íŠ¸ë¦¬ ì „ì²´ ì •ë ¬ ìƒíƒœë¥¼ ìœ ì§€í•˜ëŠ” ê²Œ ì•„ë‹ˆë¼,
"ì¤‘ì•™ ê²½ê³„"ë§Œ ë¹ ë¥´ê²Œ ìœ ì§€í•˜ëŠ” ê²ƒì´ë‹¤.

* BST ê´€ì : ì „ì²´ ìˆœì„œ ê´€ë¦¬
* ë‘ í™ ê´€ì : ì™¼ìª½ ì ˆë°˜/ì˜¤ë¥¸ìª½ ì ˆë°˜ ê²½ê³„ ê´€ë¦¬

ì¦‰ ì´ ë¬¸ì œëŠ” "ì™„ì „ ê· í˜• íŠ¸ë¦¬ ë¬¸ì œ"ë³´ë‹¤
"Streaming Median ë¬¸ì œ"ë¡œ ë³´ëŠ” ê²Œ ì •í™•í•˜ë‹¤.
