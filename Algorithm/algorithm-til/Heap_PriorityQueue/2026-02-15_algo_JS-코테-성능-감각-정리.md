# JS 코테 성능 감각 정리 (swap 함수 vs 인라인)

코테에서 JS로 힙을 구현할 때 자주 나오는 질문:

> `swap()` 함수로 빼는 것과 인라인 대입 중 뭐가 더 빠른가?

---

## 결론

- 일반 코드에서는 체감 차이가 거의 없다.
- 힙처럼 수십만 ~ 수천만 회 반복되는 루프 안에서는 차이가 누적된다.

---

## 1) 이론 비교

### 함수 호출 swap

```js
this.swap(i, j);
```

- 함수 호출 프레임 생성
- 인자 전달
- `this` 바인딩/프로퍼티 접근
- 함수 복귀

### 인라인 swap

```js
const temp = heap[i];
heap[i] = heap[j];
heap[j] = temp;
```

- 함수 호출 없음
- 즉시 대입 연산

요약:

- 1회 차이는 작아도 반복 횟수가 크면 누적된다.

---

## 2) 차이가 커지는 조건

힙 문제에서:

- `insert`: `O(log n)`
- `extract`: `O(log n)`
- `n`이 최대 `1,000,000` 수준

대략적인 swap 횟수 추정:

```txt
n * log2(n) ≈ 1,000,000 * 20 = 20,000,000
```

함수 호출이 2천만 번 누적되면 JS에서는 유의미한 시간 차이가 생길 수 있다.

---

## 3) 체감 구간

| 상황 | 체감 |
| --- | --- |
| 일반 앱 코드 | 거의 없음 |
| 알고리즘 효율성 경계 문제 | 미묘하게 차이 |
| JS(Node/V8) | 차이 나는 경우가 있음 |
| C++ | 상대적으로 차이 작음 |

---

## 4) JS 런타임 특성

- 함수 호출 오버헤드는 존재한다.
- `this.heap` 같은 프로퍼티 체인 접근도 누적되면 비용이 된다.
- V8 최적화가 도움은 되지만, 코테 입력/코드 패턴에서 항상 동일하게 보장되지는 않는다.

---

## 5) 코테 실전 가이드

- 루프 바깥/비핵심 로직: 가독성 우선(함수 분리 가능)
- `heapifyUp`, `heapifyDown` 내부: 인라인 + 지역 캐싱 추천

예시:

```js
const heap = this.heap; // 프로퍼티 접근 캐싱
const parent = (idx - 1) >> 1; // bit 연산
```

---

## 6) 성능 영향 우선순위 (힙 기준)

질문:

1. swap 함수 호출
2. `this.heap` 프로퍼티 접근
3. `Math.floor` 사용

실무/코테 체감 기준 대략 순위:

1) **함수 호출 오버헤드 (`swap`)**  
2) **프로퍼티 접근 누적 (`this.heap`)**  
3) **`Math.floor` vs 비트 연산 차이**

설명:

- 1, 2는 반복 루프에서 수천만 번 누적되기 쉽다.
- 3은 미세 최적화 성격이 강해서 보통 마지막 단계에서 챙긴다.

---

## 한 줄 정리

> swap 함수 한 번은 미미하지만, 수천만 번 반복되면 차이가 난다.
