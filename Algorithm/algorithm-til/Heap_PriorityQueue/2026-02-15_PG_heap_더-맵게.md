## ğŸ§© ë¬¸ì œ

* **ë¬¸ì œ ì œëª©** : ë” ë§µê²Œ
* **ë¬¸ì œ ë ˆë²¨** : Level 2
* **ë¬¸ì œ ìœ í˜•** : í™/ìš°ì„ ìˆœìœ„ í (Heap, Priority Queue), Greedy
* **ë¬¸ì œ ì œê³µ** : Programmers
* **ë¬¸ì œ ë§í¬** : https://school.programmers.co.kr/learn/courses/30/lessons/42626
* **ì½”ë“œ íŒŒì¼** : [more-spicy-42626.js](../../algorithm-JS/Heap_PriorityQueue/more-spicy-42626.js)

---

## ğŸ§  ë¬¸ì œ í‚¤ì›Œë“œ

* ì‚¬ìš© ì•Œê³ ë¦¬ì¦˜ : ìµœì†Œ í™(ìš°ì„ ìˆœìœ„ í) + ê·¸ë¦¬ë””
* ë§¤ë²ˆ ê°€ì¥ ì‘ì€ 2ê°œ ì¶”ì¶œ
* ìµœì†Œê°’ì´ `K` ì´ìƒì¸ì§€ ë£¨íŠ¸ë¡œ íŒì •
* ë°˜ë³µ ì¡°ê±´ ì œì–´
* íš¨ìœ¨ì„± í…ŒìŠ¤íŠ¸ ëŒ€ì‘ (`O(n log n)`)

---

## ğŸ§© ë¬¸ì œ ì„¤ëª…

ëª¨ë“  ìŒì‹ì˜ ìŠ¤ì½”ë¹Œ ì§€ìˆ˜ë¥¼ `K` ì´ìƒìœ¼ë¡œ ë§Œë“¤ê¸° ìœ„í•´,
ê°€ì¥ ë§µì§€ ì•Šì€ ë‘ ìŒì‹ì„ ì•„ë˜ ê·œì¹™ìœ¼ë¡œ ë°˜ë³µí•´ì„œ ì„ëŠ”ë‹¤.

* ìƒˆ ìŠ¤ì½”ë¹Œ = ê°€ì¥ ë‚®ì€ ê°’ + (ë‘ ë²ˆì§¸ë¡œ ë‚®ì€ ê°’ * 2)

ìµœì†Œ ëª‡ ë²ˆ ì„ì–´ì•¼ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ”ì§€ êµ¬í•˜ê³ ,
ë¶ˆê°€ëŠ¥í•˜ë©´ `-1`ì„ ë°˜í™˜í•˜ëŠ” ë¬¸ì œë‹¤.

---

## ğŸ§© ì œí•œì‚¬í•­

* `2 â‰¤ scoville.length â‰¤ 1,000,000`
* `0 â‰¤ K â‰¤ 1,000,000,000`
* `0 â‰¤ scoville[i] â‰¤ 1,000,000`

---

## ğŸ§© ì…ì¶œë ¥ ì˜ˆ

| scoville | K | result |
| --- | --- | --- |
| [1, 2, 3, 9, 10, 12] | 7 | 2 |

### ì…ì¶œë ¥ ì˜ˆ ì„¤ëª…

* 1, 2ë¥¼ ì„ì–´ 5 ìƒì„±
* 3, 5ë¥¼ ì„ì–´ 13 ìƒì„±
* ìµœì†Œê°’ì´ 7 ì´ìƒì´ ë˜ì–´ ì´ 2íšŒ

---

## ğŸ§© ë¬¸ì œ í•µì‹¬ í¬ì¸íŠ¸

* ë§¤ ë‹¨ê³„ì—ì„œ í•„ìš”í•œ ê±´ "ê°€ì¥ ì‘ì€ 2ê°œ" ì¶”ì¶œì´ë‹¤.
* ë°°ì—´ ì •ë ¬ì„ ë§¤ë²ˆ ë‹¤ì‹œ í•˜ë©´ ë¹„ìš©ì´ í¬ë¯€ë¡œ ìµœì†Œ í™ì´ ì í•©í•˜ë‹¤.
* ìµœì†Œ í™ ë£¨íŠ¸ê°€ `K` ì´ìƒì´ë©´ ì „ì²´ê°€ `K` ì´ìƒì´ë‹¤.

---

## ğŸ§© ë‚´ í’€ì´ ë°©ì‹

* `scoville`ë¥¼ ëª¨ë‘ ìµœì†Œ í™ì— ë„£ëŠ”ë‹¤.
* `heap.size() > 1 && heap.peek() < K` ë™ì•ˆ ë°˜ë³µí•œë‹¤.
* ìµœì†Œê°’ 2ê°œë¥¼ êº¼ë‚´ ì„ì€ ê°’ì„ ë‹¤ì‹œ í™ì— ë„£ê³  ì¹´ìš´íŠ¸ ì¦ê°€.
* ë°˜ë³µ ì¢…ë£Œ í›„ ë£¨íŠ¸ê°€ `K` ì´ìƒì´ë©´ ì¹´ìš´íŠ¸, ì•„ë‹ˆë©´ `-1` ë°˜í™˜.

---

## ğŸ§© ì½”ë“œ ë¡œì§ ì •ë¦¬

### ì „ì²´ íë¦„

```txt
1. ìµœì†Œ í™ ìƒì„± í›„ scoville ì „ë¶€ ì‚½ì…
2. í™ ì›ì†Œê°€ 2ê°œ ì´ìƒì´ê³  ìµœì†Œê°’ì´ Kë³´ë‹¤ ì‘ìœ¼ë©´ ë°˜ë³µ
3. ìµœì†Œê°’ 2ê°œë¥¼ êº¼ë‚´ ìƒˆ ìŠ¤ì½”ë¹Œ ê³„ì‚° í›„ ì‚½ì…
4. ì„ì€ íšŸìˆ˜ +1
5. ë£¨íŠ¸ê°€ K ì´ìƒì´ë©´ count ë°˜í™˜, ì•„ë‹ˆë©´ -1
```

---

## ğŸ§© ì½”ë“œ êµ¬í˜„ (ë‚´ í’€ì´)

```js
class MinHeap {
  constructor() {
    this.heap = [];
  }

  size() {
    return this.heap.length;
  }

  peek() {
    return this.heap.length ? this.heap[0] : null;
  }

  insert(value) {
    const heap = this.heap;
    heap.push(value);
    this.heapifyUp();
  }

  extractMin() {
    const heap = this.heap;

    if (heap.length === 0) return null;
    if (heap.length === 1) return heap.pop();

    const min = heap[0];
    heap[0] = heap.pop();
    this.heapifyDown();
    return min;
  }

  heapifyUp() {
    const heap = this.heap;
    let currentIndex = heap.length - 1;

    while (currentIndex > 0) {
      const parentIndex = (currentIndex - 1) >> 1;
      if (heap[parentIndex] <= heap[currentIndex]) break;

      const temp = heap[parentIndex];
      heap[parentIndex] = heap[currentIndex];
      heap[currentIndex] = temp;

      currentIndex = parentIndex;
    }
  }

  heapifyDown() {
    const heap = this.heap;
    const length = heap.length;
    let currentIndex = 0;

    while (true) {
      const leftChildIndex = 2 * currentIndex + 1;
      const rightChildIndex = 2 * currentIndex + 2;
      let minIndex = currentIndex;

      if (leftChildIndex < length && heap[leftChildIndex] < heap[minIndex]) {
        minIndex = leftChildIndex;
      }

      if (rightChildIndex < length && heap[rightChildIndex] < heap[minIndex]) {
        minIndex = rightChildIndex;
      }

      if (minIndex === currentIndex) break;

      const temp = heap[minIndex];
      heap[minIndex] = heap[currentIndex];
      heap[currentIndex] = temp;
      currentIndex = minIndex;
    }
  }
}

function solution(scoville, K) {
  const minHeap = new MinHeap();

  for (const value of scoville) {
    minHeap.insert(value);
  }

  let count = 0;

  while (minHeap.size() > 1 && minHeap.peek() < K) {
    const first = minHeap.extractMin();
    const second = minHeap.extractMin();
    minHeap.insert(first + second * 2);
    count += 1;
  }

  return minHeap.peek() !== null && minHeap.peek() >= K ? count : -1;
}
```

---

## ğŸ§© ì‹œí–‰ì°©ì˜¤ ë° ìˆ˜ì • ì‚¬í•­

### 1) `shift()` ì‚¬ìš©ìœ¼ë¡œ ì‹œê°„ ì´ˆê³¼

ê¸°ì¡´:

```js
scoville.shift();
```

ë¬¸ì œ:

* `shift()`ëŠ” `O(n)`ì´ë¼ ë°˜ë³µ ì‹œ `O(n^2)`ê¹Œì§€ ì˜¬ë¼ê°„ë‹¤.

ìˆ˜ì •:

* ë°°ì—´ ì• ì œê±° ëŒ€ì‹  í™ì˜ `extractMin()` ì‚¬ìš©
* ìµœì†Œê°’ ì¶”ì¶œì„ `O(log n)`ìœ¼ë¡œ ìœ ì§€

### 2) ë°˜ë³µ ì¡°ê±´ì„ ì›ë³¸ ë°°ì—´ ê¸°ì¤€ìœ¼ë¡œ ë‘” ì‹¤ìˆ˜

ê¸°ì¡´:

```js
while (scoville.length !== 0)
```

ë¬¸ì œ:

* ì‹¤ì œ ìƒíƒœëŠ” í™ì— ìˆëŠ”ë°, ì›ë³¸ ë°°ì—´ ê¸¸ì´ë¡œ ì¢…ë£Œë¥¼ íŒë‹¨í•˜ë©´ ì˜¤ë™ì‘ ê°€ëŠ¥

ìˆ˜ì •:

```js
while (minHeap.size() > 1 && minHeap.peek() < K)
```

### 3) swap ë¡œì§ ì˜¤ë¥˜

ë¬¸ì œ:

* ëŒ€ì… ìˆœì„œ ì‹¤ìˆ˜ë¡œ ê°’ ë³µì œ/ìœ ì‹¤ì´ ìƒê²¨ í™ êµ¬ì¡°ê°€ ê¹¨ì§

ìˆ˜ì •:

```js
const temp = heap[parentIndex];
heap[parentIndex] = heap[currentIndex];
heap[currentIndex] = temp;
```

### 4) `heapifyUp`ì—ì„œ ë¶€ëª¨ ì¸ë±ìŠ¤ ê°±ì‹  ëˆ„ë½

ë¬¸ì œ:

* í•œ ë‹¨ê³„ë§Œ ë¹„êµí•˜ê³  ëë‚˜ë©´ ë£¨íŠ¸ê¹Œì§€ ì˜¬ë¼ê°€ì§€ ëª»í•´ í™ ë¶ˆë³€ì‹ì´ ê¹¨ì§ˆ ìˆ˜ ìˆìŒ

ìˆ˜ì •:

```js
while (currentIndex > 0) {
  const parentIndex = (currentIndex - 1) >> 1;
  ...
}
```

### 5) ë¶ˆí•„ìš”í•œ ì •ë ¬ ì œê±°

ê¸°ì¡´:

```js
scoville.sort((a, b) => a - b);
```

ë¬¸ì œ:

* í™ì„ ì“°ëŠ” ê²½ìš° ë§¤ë²ˆ ì •ë ¬ì€ ì¤‘ë³µ ë¹„ìš©

ìˆ˜ì •:

* ì •ë ¬ ì—†ì´ í™ ì—°ì‚°ë§Œ ì‚¬ìš©

---

## ğŸ§© ì„±ëŠ¥ ìµœì í™” í¬ì¸íŠ¸

* `const heap = this.heap`ë¡œ ë°˜ë³µ í”„ë¡œí¼í‹° ì ‘ê·¼ ê°ì†Œ
* `swap` í•¨ìˆ˜ í˜¸ì¶œ ëŒ€ì‹  ì¸ë¼ì¸ êµí™˜
* `length` ìºì‹±ìœ¼ë¡œ ë°˜ë³µ ì ‘ê·¼ ìµœì†Œí™”
* ë¶€ëª¨ ì¸ë±ìŠ¤ ê³„ì‚°ì— ë¹„íŠ¸ ì—°ì‚°(`>> 1`) ì‚¬ìš©

---

## ğŸ§© ë³µì¡ë„

* ì‹œê°„ë³µì¡ë„ : `O(n log n)` (í™ ì‚½ì… + ì„ê¸° ë°˜ë³µ)
* ê³µê°„ë³µì¡ë„ : `O(n)` (ìµœì†Œ í™)

---

## ğŸ§  ì‚¬ê³  í‚¤ì›Œë“œ

* ìµœì†Œê°’ 2ê°œ ë°˜ë³µ ì¶”ì¶œ
* ì¡°ê±´ ë§Œì¡±ê¹Œì§€ ë°˜ë³µ
* ìë£Œêµ¬ì¡° ì„ íƒì´ ì„±ëŠ¥ì„ ê²°ì •
* ë£¨íŠ¸ ê°’ìœ¼ë¡œ ì „ì²´ ì¡°ê±´ íŒì •

---

## ğŸ” íŠ¸ë¦¬ê±° ë¬¸ì¥

* "ê°€ì¥ ì‘ì€ ë‘ ê°’ì„ ë°˜ë³µí•´ì„œ ì‚¬ìš©í•œë‹¤."
* "ë§¤ ë‹¨ê³„ ìµœì†Œê°’ ì¡°íšŒ/ì¶”ì¶œì´ í•µì‹¬ì´ë‹¤."

---

## âš ï¸ ì˜¤ë‹µ í¬ì¸íŠ¸

* í™ ëŒ€ì‹  ë°°ì—´ ì• ì‚­ì œ(`shift`)ë¥¼ ì“°ë©´ íš¨ìœ¨ì„± ì‹¤íŒ¨ ê°€ëŠ¥ì„± í¼
* ì¢…ë£Œ ì¡°ê±´ì—ì„œ í™ ì›ì†Œ ê°œìˆ˜/ë£¨íŠ¸ ì²´í¬ë¥¼ ë¹¼ë©´ ì˜¤ë‹µ ê°€ëŠ¥
* ë§ˆì§€ë§‰ì— í™ ë£¨íŠ¸ê°€ `K` ë¯¸ë§Œì¸ ê²½ìš° `-1` ì²˜ë¦¬ ëˆ„ë½ ì£¼ì˜

---

## ğŸ§© ë°°ìš´ ì 

1. í™ êµ¬í˜„ì—ì„œ `swap`ê³¼ ì¸ë±ìŠ¤ ê°±ì‹ ì´ ê°€ì¥ ì¤‘ìš”í•˜ë‹¤.
2. JSì—ì„œëŠ” ë™ì¼ ë³µì¡ë„ë¼ë„ êµ¬í˜„ ë””í…Œì¼ì´ ì„±ëŠ¥ ì°¨ì´ë¥¼ ë§Œë“ ë‹¤.
3. ì´ ë¬¸ì œëŠ” "ì •ë ¬ ë¬¸ì œ"ê°€ ì•„ë‹ˆë¼ "ì¡°ê±´ì„ ìœ ì§€í•˜ëŠ” í™ ë¬¸ì œ"ì˜€ë‹¤.

---

## ğŸ§© í•œ ì¤„ íšŒê³ 

> í™ ê°œë… ì´í•´ì™€ JS ì„±ëŠ¥ ê°ê°ì„ ë™ì‹œì— ì ê²€í•  ìˆ˜ ìˆëŠ” ë¬¸ì œì˜€ë‹¤.
